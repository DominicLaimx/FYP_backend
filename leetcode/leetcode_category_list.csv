question_text,summary,example,constraints,leetcode_link,title,category,solution
"You are given two integer arrays `nums1` and `nums2`, sorted in non-decreasing order, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively. Merge `nums1` and `nums2` into a single array sorted in non-decreasing order, storing the result in `nums1`.",Merge two sorted arrays,"Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3; Output: [1,2,2,3,5,6]","nums1.length == m + n, nums2.length == n, 0 <= m, n <= 200, 1 <= m + n <= 200, -10^9 <= nums1[i], nums2[j] <= 10^9",https://leetcode.com/problems/Merge-Sorted-Array/,Merge Sorted Array,Array and String,"['class Solution:\n    def merge(self, nums1: list[int], m: int, nums2: list[int], n: int) -> None:\n        """"""\n        Do not return anything, modify nums1 in-place instead.\n        """"""\n        # Time: O(m + n) - Space O(1)\n        # starting indices for nums1, nums2, and the end of merged array\n        i, j, k = m - 1, n - 1, m + n - 1\n\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                # place the larger element (now nums1[i]) at the end of nums1\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                # place the larger element (now nums2[j]) at the end of nums1\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n\n        while j >= 0:\n            # place the remaining elements of nums2 from nums2 to nums1\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1', '# Example usage\nnums1 = [1, 2, 3, 0, 0, 0]\nm = 3\nnums2 = [2, 5, 6]\nn = 3\n\nmerge = Solution().merge\n\nmerge(nums1, m, nums2, n)\nprint(nums1)  # Output should be [1,2,2,3,5,6]']"
"Given an integer array nums, find the subarray with the largest sum, and return its sum.",Find maximum subarray sum,"Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6",1 <= nums.length <= 10^5; -10^4 <= nums[i] <= 10^4,https://leetcode.com/problems/Maximum-Subarray/,Maximum Subarray,Kadane’s Algorithm,"['class Solution:\n    def maxSubArray(self, nums: list[int]) -> int:\n        local_max = 0\n        global_max = -float(""inf"")\n\n        for num in nums:\n            local_max = max(num, num + local_max)\n            global_max = max(local_max, global_max)\n\n        return global_max', '# Test case\ns = Solution()\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(s.maxSubArray(nums))  # Output: 6', ""def maxSubArray(nums):\n    def maxCrossingSum(nums, left, mid, right):\n        # Include at least one element from left half\n        sum_left = float('-inf')\n        current_sum = 0\n        for i in range(mid, left - 1, -1):\n            current_sum += nums[i]\n            if current_sum > sum_left:\n                sum_left = current_sum\n\n        # Include at least one element from right half\n        sum_right = float('-inf')\n        current_sum = 0\n        for i in range(mid + 1, right + 1):\n            current_sum += nums[i]\n            if current_sum > sum_right:\n                sum_right = current_sum\n\n        # Return sum of elements on left and right of mid\n        # as it's the maximum sum of subarray crossing mid\n        return sum_left + sum_right\n\n    def maxSubArrayRec(nums, left, right):\n        if left == right:  # Base case: only one element\n            return nums[left]\n\n        mid = (left + right) // 2\n        left_max = maxSubArrayRec(nums, left, mid)\n        right_max = maxSubArrayRec(nums, mid + 1, right)\n        cross_max = maxCrossingSum(nums, left, mid, right)\n\n        return max(left_max, right_max, cross_max)\n\n    return maxSubArrayRec(nums, 0, len(nums) - 1)\n\n\n# Example usage:\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArray(nums))  # Output: 6""]"
"Given a circular integer array `nums`, return the maximum possible sum of a non-empty subarray of `nums`.",Maximum sum circular subarray,"Input: nums = [1,-2,3,-2] Output: 3; Input: nums = [5,-3,5] Output: 10; Input: nums = [-3,-2,-3] Output: -2.",1 <= n <= 3 * 10^4; -3 * 10^4 <= nums[i] <= 3 * 10^4.,https://leetcode.com/problems/Maximum-Sum-Circular-Subarray/,Maximum Sum Circular Subarray,Kadane’s Algorithm,"[""class Solution:\n    def maxSubarraySumCircular(self, nums: list[int]) -> int:\n        def kadane(nums: list[int]) -> int:\n            max_sum = float('-inf')\n            current_sum = 0\n            for num in nums:\n                current_sum = max(num, current_sum + num)\n                max_sum = max(max_sum, current_sum)\n            return max_sum\n        \n        # step 1: find the max sum of non-circular subarray\n        max_kadane = kadane(nums)\n        \n        # step 2: find the total sum of the array and the min sum of non-circular subarray\n        total_sum = sum(nums)\n        \n        # invert the sign of each element in the array\n        nums_inverted = [-num for num in nums]\n        max_kadane_inverted = kadane(nums_inverted)\n        min_subarray_sum = -max_kadane_inverted\n        \n        # step 3: find the max sum of circular subarray\n        max_circular = total_sum - min_subarray_sum\n        \n        # step 4: handle the edge case\n        if max_circular == 0:\n            return max_kadane\n        \n        return max(max_kadane, max_circular)"", 's = Solution()\n\nprint(s.maxSubarraySumCircular([1, -2, 3, -2]))  # Output: 3\nprint(s.maxSubarraySumCircular([5, -3, 5]))      # Output: 10\nprint(s.maxSubarraySumCircular([-3, -2, -3]))    # Output: -2']"
"You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n. Merge nums1 and nums2 into a single array sorted in non-decreasing order, storing the result in nums1.",Merge two sorted arrays,"Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3; Output: [1,2,2,3,5,6]","nums1.length == m + n, nums2.length == n, 0 <= m, n <= 200, 1 <= m + n <= 200, -10^9 <= nums1[i], nums2[j] <= 10^9",https://leetcode.com/problems/Merge-Sorted-Array/,Merge Sorted Array,Array and String,"['class Solution:\n    def merge(self, nums1: list[int], m: int, nums2: list[int], n: int) -> None:\n        """"""\n        Do not return anything, modify nums1 in-place instead.\n        """"""\n        # Time: O(m + n) - Space O(1)\n        # starting indices for nums1, nums2, and the end of merged array\n        i, j, k = m - 1, n - 1, m + n - 1\n\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                # place the larger element (now nums1[i]) at the end of nums1\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                # place the larger element (now nums2[j]) at the end of nums1\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n\n        while j >= 0:\n            # place the remaining elements of nums2 from nums2 to nums1\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1', '# Example usage\nnums1 = [1, 2, 3, 0, 0, 0]\nm = 3\nnums2 = [2, 5, 6]\nn = 3\n\nmerge = Solution().merge\n\nmerge(nums1, m, nums2, n)\nprint(nums1)  # Output should be [1,2,2,3,5,6]']"
Implement the `removeElement` function to remove all occurrences of a specific value (`val`) from an array (`nums`) and return the count of remaining elements.,Remove specific value from array,"Input: nums = [3, 2, 2, 3], val = 3; Output: 2, nums = [2, 2, _, _]",The function should operate in O(n) time and O(1) space.,https://leetcode.com/problems/Remove-Element/,Remove Element,Array and String,"['class Solution:\n    def removeElement(self, nums: list[int], val: int) -> int:\n        k = 0\n        for i in range(len(nums)):\n            if nums[i] != val:\n                nums[k] = nums[i]\n                k += 1\n        return k', '# Test the function with the provided examples\nremoveElement = Solution().removeElement\n\nexample1 = [3, 2, 2, 3]\nval1 = 3\noutput1 = removeElement(example1, val1)\n\nexample2 = [0, 1, 2, 2, 3, 0, 4, 2]\nval2 = 2\noutput2 = removeElement(example2, val2)\n\noutput1, example1, output2, example2']"
What is the time and space complexity of the removeDuplicates function?,Analyze removeDuplicates complexity,"Input: [1, 1, 2], Output: [1, 2]",Function modifies the array in place.,https://leetcode.com/problems/Remove-Duplicates-from-Sorted-Array/,Remove Duplicates from Sorted Array,Array and String,"['class Solution:\n    def removeDuplicates(self, nums: list[int]) -> int:\n        if not nums:\n            return 0\n\n        # initialize the unique element index\n        i = 0\n\n        for j in range(len(nums)):\n            # check if the current element is different from the one at the unique index\n            if nums[j] != nums[i]:\n                # move the unique index forward and update its value\n                i += 1\n                nums[i] = nums[j]\n\n        # return the number of unique elements\n        return i + 1', '# Testing the function with the provided examples\n\nremoveDuplicates = Solution().removeDuplicates\n\nnums1 = [1, 1, 2]\nresult1 = removeDuplicates(nums1)\n\nnums2 = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]\nresult2 = removeDuplicates(nums2)\n\nresult1, nums1, result2, nums2']"
"Given a sorted integer array, remove duplicates in-place such that each unique element appears at most twice and return the new length.",Remove duplicates from array,"Input: nums = [1,1,1,2,2,3], Output: 5, nums = [1,1,2,2,3,_]",1 <= nums.length <= 3 * 10^4; -10^4 <= nums[i] <= 10^4; nums is sorted in non-decreasing order.,https://leetcode.com/problems/Remove-Duplicates-from-Sorted-Array-II/,Remove Duplicates from Sorted Array II,Array and String,"['class Solution:\n    # O(n) time complexity: one pass through nums\n    # O(1) space complexity: only two pointers used\n    def removeDuplicates(self, nums: list[int]) -> int:\n        # init two pointers. i is the slow-runner, j is the fast-runner\n        i = 0\n\n        for j in range(len(nums)):\n            # check if the current value is equal to the value at i - 2 (to allow max 2 duplicates)\n            if i < 2 or nums[j] != nums[i - 2]:\n                nums[i] = nums[j]\n                i += 1\n\n        return i', '# Test the function with the provided examples\n\nremoveDuplicates = Solution().removeDuplicates\n\ntest1 = [1, 1, 1, 2, 2, 3]\ntest2 = [0, 0, 1, 1, 1, 1, 2, 3, 3]\n\nk1 = removeDuplicates(test1)\nk2 = removeDuplicates(test2)\n\n(k1, test1[:k1]), (k2, test2[:k2])']"
"Given an array `nums` of size `n`, return the majority element that appears more than `⌊n / 2⌋` times. Assume that the majority element always exists in the array.",Find majority element,"Input: nums = [3,2,3] Output: 3; Input: nums = [2,2,1,1,1,2,2] Output: 2","n == nums.length, 1 <= n <= 5 * 10^4, -10^9 <= nums[i] <= 10^9",https://leetcode.com/problems/Majority-Element/,Majority Element,Array and String,"['class Solution:\n    def majorityElement(self, nums: list[int]) -> int:\n        # Boyer-Moore Voting Algorithm\n        count = 0\n        candidate = None\n\n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += 1 if num == candidate else -1\n\n        return candidate', '# Testing the function with the provided examples\nmajorityElement = Solution().majorityElement\n\nexample1 = [3, 2, 3]\nexample2 = [2, 2, 1, 1, 1, 2, 2]\n\noutput1 = majorityElement(example1)\noutput2 = majorityElement(example2)\n\noutput1, output2']"
"Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",Rotate array to the right,"Input: nums = [1,2,3,4,5,6,7], k = 3; Output: [5,6,7,1,2,3,4]",1 <= nums.length <= 105; -231 <= nums[i] <= 231 - 1; 0 <= k <= 105,https://leetcode.com/problems/Rotate-Array/,Rotate Array,Array and String,"['class Solution:\n    def rotate(self, nums: list[int], k: int) -> None:\n        # time complexity: O(n), space complexity: O(n)\n        """"""\n        Do not return anything, modify nums in-place instead.\n        """"""\n        """"""\n        Rotate the elements of the array to the right by k steps.\n\n        :param nums: List[int] - the array to rotate\n        :param k: int - number of steps to rotate the array\n        :return: List[int] - the rotated array\n        """"""\n        # If k is greater than the length of the array, rotating the array k times would effectively be the same as rotating it k % len(nums)\n        k = k % len(nums)\n        # Rotate the array by reversing parts of the array; nums[-k:] get the last k elements, nums[:-k] get all the elements except the last k elements\n        nums[:] = nums[-k:] + nums[:-k]\n        return nums\n\n    def rotate_in_place(self, nums: list[int], k: int) -> None:\n        # time complexity: O(n), space complexity: O(1)\n        def reverse(sub_nums: list[int], start: int, end: int) -> None:\n            while start < end:\n                sub_nums[start], sub_nums[end] = sub_nums[end], sub_nums[start]\n                start += 1\n                end -= 1\n\n        n = len(nums)\n        k = k % n  # effective rotation\n\n        # reverse the whole array\n        reverse(nums, 0, n - 1)\n        # reverse the first k elements\n        reverse(nums, 0, k - 1)\n        # reverse the last n-k elements\n        reverse(nums, k, n - 1)\n\n        return nums', '# Test the function with the provided examples\n\nrotate = Solution().rotate\nrotate_in_place = Solution().rotate_in_place\n\nexample1 = rotate([1, 2, 3, 4, 5, 6, 7], 3)\nexample2 = rotate([-1, -100, 3, 99], 2)\n\nprint(example1, example2)\n\ninstance1 = rotate_in_place([1, 2, 3, 4, 5, 6, 7], 3)\ninstance2 = rotate_in_place([-1, -100, 3, 99], 2)\n\nprint(instance1, instance2)']"
"Given an array of stock prices, determine the maximum profit from a single buy-sell transaction.",Maximize stock trading profit,"Input: prices = [7,1,5,3,6,4], Output: 5; Input: prices = [7,6,4,3,1], Output: 0",1 <= prices.length <= 105; 0 <= prices[i] <= 104,https://leetcode.com/problems/Best-Time-to-Buy-and-Sell-Stock/,Best Time to Buy and Sell Stock,Array and String,"['class Solution:\n    # Time: O(n), Space: O(1)\n    def maxProfit(self, prices: list[int]) -> int:\n        if not prices:\n            return 0\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices:\n            # update min_price found so far\n            if price < min_price:\n                min_price = price\n            else:\n                # calculat profit if sold at the current price\n                profit = price - min_price\n                # update max_profit found so far\n                max_profit = max(max_profit, profit)\n        \n        return max_profit\n            ', '# Testing the function with the same examples\nexample1 = [7, 1, 5, 3, 6, 4]\nexample2 = [7, 6, 4, 3, 1]\n\nmaxProfit = Solution().maxProfit\n\noutput1_simple = maxProfit(example1)\noutput2_simple = maxProfit(example2)\n\noutput1_simple, output2_simple']"
"Given an integer array `prices`, find the maximum profit from buying and selling stock on different days, with the option to buy and sell on the same day.",Maximize stock profit,"Input: prices = [7,1,5,3,6,4] Output: 7",1 <= prices.length <= 3 * 10^4; 0 <= prices[i] <= 10^4,https://leetcode.com/problems/Best-Time-to-Buy-and-Sell-Stock-II/,Best Time to Buy and Sell Stock II,Array and String,"['class Solution:\n    # solve with O(n) time complexity and O(1) space complexity\n    def maxProfit(self, prices: list[int]) -> int:\n        # init profit to 0\n        profit = 0\n\n        # iterate through the list of prices\n        for i in range(1, len(prices)):\n            # if the price on the current day is higher than the previous day\n            if prices[i] > prices[i - 1]:\n                # add the difference to the profit\n                profit += prices[i] - prices[i - 1]\n\n        # return the profit\n        return profit', 'maxProfit = Solution().maxProfit\n\nprint(maxProfit([7, 1, 5, 3, 6, 4]))  # 7\nprint(maxProfit([1, 2, 3, 4, 5]))  # 4\nprint(maxProfit([7, 6, 4, 3, 1]))  # 0']"
"Given an integer array nums, determine if you can reach the last index starting from the first index, where each element represents the maximum jump length at that position.",Jump Game Problem,"Input: nums = [2,3,1,1,4] Output: true; Input: nums = [3,2,1,0,4] Output: false",1 <= nums.length <= 104; 0 <= nums[i] <= 105,https://leetcode.com/problems/Jump-Game/,Jump Game,Array and String,"[""class Solution:\n    # Greedy Algorithm: at each step, jump as far as possible\n    # Time: O(n), Space: O(1)\n    def canJump(self, nums: list[int]) -> bool:\n        max_reach = 0\n        for i in range(len(nums)):\n            # if we can't reach this index, we are stuck\n            if i > max_reach:\n                return False\n            # update max_reach with the current max_reach and the farthest we can jump from this index (i + num[i])\n            max_reach = max(max_reach, i + nums[i])\n        # check if max_reach is at least the last index of the array\n        return max_reach >= len(nums) - 1"", '# Test cases\ntest_case1 = [2, 3, 1, 1, 4]\ntest_case2 = [3, 2, 1, 0, 4]\n\n# Test\ncanJump = Solution().canJump\n\nprint(canJump(test_case1))\nprint(canJump(test_case2))']"
"Given a 0-indexed array of integers nums, return the minimum number of jumps to reach the last index from the first index, where each element represents the maximum jump length from that index.",Minimum jumps to end,"Input: nums = [2,3,1,1,4] Output: 2","The array length n is at least 1, and the test cases are generated such that you can reach nums[n - 1].",https://leetcode.com/problems/Jump-Game-II/,Jump Game II,Array and String,"[""class Solution:\n    def jump(self, nums: list[int]) -> int:\n        n = len(nums)\n        if n <= 1:\n            return 0\n\n        # keep count of number of jumps\n        jumps = 0\n\n        # keep track of the end of the current jump\n        current_jump_end = 0\n\n        # keep track of the farthest point we can reach\n        farthest = 0\n\n        # iterate through the array except the last element as we don't need to jump from the last element\n        for i in range(n - 1):\n            # update farthest point we can reach\n            farthest = max(farthest, i + nums[i])\n\n            # if we have reached the end of the current jump, so we have to make a jump\n            if i == current_jump_end:\n                jumps += 1\n                current_jump_end = farthest\n\n                # if we have reached the end of the array, we don't need to jump anymore\n                if current_jump_end >= n - 1:\n                    break\n\n        return jumps"", '# Test the function with the provided examples\n\njump = Solution().jump\n\nexample1 = [2, 3, 1, 1, 4]\nexample2 = [2, 3, 0, 1, 4]\n\noutput1 = jump(example1)\noutput2 = jump(example2)\n\noutput1, output2']"
"Given an array of integers citations, return the researcher's h-index based on the definition that h-index is the maximum value of h such that the researcher has published at least h papers that have each been cited at least h times.",Calculate researcher's h-index,"Input: citations = [3,0,6,1,5] Output: 3; Input: citations = [1,3,1] Output: 1",1 <= n <= 5000; 0 <= citations[i] <= 1000,https://leetcode.com/problems/H-Index/,H-Index,Array and String,"['class Solution:\n    # O(n logn) time complexity: sorting\n    # O(1) space complexity: in-place sorting\n    def hIndex(self, citations: list[int]) -> int:\n        # sort the citations in descending order\n        citations.sort(reverse=True)\n\n        # initialize the h-index to 0\n        h_index = 0\n\n        # iterate through the citations\n        for i in range(len(citations)):\n            # if the citation is greater than or equal to the h-index\n            if citations[i] >= h_index + 1:\n                # increment the h-index\n                h_index += 1\n            # otherwise\n            else:\n                # break out of the loop to avoid unnecessary iterations\n                break\n\n        # return the h-index\n        return h_index', '# Test cases\n\nh_index = Solution().hIndex\n\ntest_case_1 = [3, 0, 6, 1, 5]\ntest_case_2 = [1, 3, 1]\n\noutput_1 = h_index(test_case_1)\noutput_2 = h_index(test_case_2)\n\noutput_1, output_2']"
"Implement a RandomizedSet class with insert, remove, and getRandom methods that operate in average O(1) time complexity.",RandomizedSet class operations,"insert(1) -> True, remove(2) -> False, insert(2) -> True, getRandom() -> 2, remove(1) -> True, insert(2) -> False, getRandom() -> 2",All operations must have average O(1) time complexity.,https://leetcode.com/problems/Insert-Delete-Get-Random-O(1)/,Insert Delete Get Random O(1),Array and String,"['from random import choice\n\n\nclass RandomizedSet:\n    def __init__(self):\n        self.num_dict = {}\n        self.num_list = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.num_dict:\n            return False\n\n        self.num_dict[val] = len(self.num_list)\n        self.num_list.append(val)\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.num_dict:\n            return False\n\n        index = self.num_dict[val]\n        last = self.num_list[-1]\n\n        self.num_list[index] = last\n        self.num_dict[last] = index\n\n        self.num_list.pop()\n        del self.num_dict[val]\n\n        return True\n\n    def getRandom(self) -> int:\n        return choice(self.num_list)\n\n\n# Your RandomizedSet object will be instantiated and called as such:\n# obj = RandomizedSet()\n# param_1 = obj.insert(val)\n# param_2 = obj.remove(val)\n# param_3 = obj.getRandom()', '# Test the RandomizedSet class based on the provided example\nrandomizedSet = RandomizedSet()\noperations = [\n    ""RandomizedSet"",\n    ""insert"",\n    ""remove"",\n    ""insert"",\n    ""getRandom"",\n    ""remove"",\n    ""insert"",\n    ""getRandom"",\n]\nvalues = [[], [1], [2], [2], [], [1], [2], []]\nresults = []\n\nfor op, val in zip(operations, values):\n    if op == ""RandomizedSet"":\n        results.append(None)\n    elif op == ""insert"":\n        results.append(randomizedSet.insert(val[0]))\n    elif op == ""remove"":\n        results.append(randomizedSet.remove(val[0]))\n    elif op == ""getRandom"":\n        results.append(randomizedSet.getRandom())\n\nresults']"
"Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`. The algorithm must run in `O(n)` time and cannot use the division operation.",Product of Array Except Self,"Input: nums = [1,2,3,4] Output: [24,12,8,6]; Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0]",2 <= nums.length <= 105; -30 <= nums[i] <= 30; The product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer.,https://leetcode.com/problems/Product-of-Array-Except-Self/,Product of Array Except Self,Array and String,"[""class Solution:\n    def productExceptSelf(self, nums: list[int]) -> list[int]:\n        # length of the input array\n        length = len(nums)\n\n        # The answer array to be returned\n        ans = [0] * length\n\n        # ans[i] contains the product of all the elements to the left\n        # Note: for the element at index '0', there are no elements to the left,\n        # so the ans[0] would be 1\n        ans[0] = 1\n\n        for i in range(1, length):\n            # ans[i - 1] already contains the product of elements to the left of 'i - 1'\n            # Simply multiplying it with nums[i - 1] would give the product of all\n            # elements to the left of index 'i'\n            ans[i] = nums[i - 1] * ans[i - 1]\n\n        # R contains the product of all the elements to the right\n        # Note: for the element at index 'length - 1', there are no elements to the right,\n        # so the R would be 1\n        r = 1\n\n        for i in reversed(range(length)):\n            # For the index 'i', R would contain the\n            # product of all elements to the right. We update R accordingly\n            ans[i] = ans[i] * r\n            r *= nums[i]\n\n        return ans"", '# Test the function with the provided examples\n\nproductExceptSelf = Solution().productExceptSelf\n\nexample1 = [1, 2, 3, 4]\nexample2 = [-1, 1, 0, -3, 3]\n\noutput1 = productExceptSelf(example1)\noutput2 = productExceptSelf(example2)\n\noutput1, output2']"
What are the time and space complexities of the can_complete_circuit function?,Analyze can_complete_circuit complexity,"Input: gas = [1,2,3], cost = [1,2,3] Output: Time Complexity: O(n), Space Complexity: O(1)",n is the number of gas stations,https://leetcode.com/problems/Gas-Station/,Gas Station,Array and String,"['class Solution:\n    def canCompleteCircuit(self, gas: list[int], cost: list[int]) -> int:\n        if sum(gas) < sum(cost):\n            return -1\n\n        start = 0\n        tank = 0\n\n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n\n        return start', '# Test cases\n\ncan_complete_circuit = Solution().canCompleteCircuit\n\ntest_case_1 = ([1, 2, 3, 4, 5], [3, 4, 5, 1, 2])  # Expected output: 3\ntest_case_2 = ([2, 3, 4], [3, 4, 3])  # Expected output: -1\n\n# Run test cases\nresult_1 = can_complete_circuit(*test_case_1)  # asterisk (*) is used to unpack an iterable.\nresult_2 = can_complete_circuit(*test_case_2)\n\nresult_1, result_2']"
"Given an array of ratings for n children, determine the minimum number of candies needed to distribute such that each child has at least one candy and children with higher ratings receive more candies than their neighbors.",Minimum candies distribution problem,"Input: ratings = [1,0,2] Output: 5; Input: ratings = [1,2,2] Output: 4",1 <= n <= 2 * 10^4; 0 <= ratings[i] <= 2 * 10^4,https://leetcode.com/problems/Candy/,Candy,Array and String,"[""class Solution:\n    def candy(self, ratings: list[int]) -> int:\n        n = len(ratings)\n\n        # each child must have at least one candy\n        candies = [1] * n\n\n        # left pass\n        # for each child (starting from the second one), compare with the previous child\n        for i in range(1, n):\n            # if current child has higher rating than the previous one, give one more candy to the current child\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        # right pass\n        # for each child (starting from the second-to-last one), compare with the next child\n        for i in range(n - 2, -1, -1):\n            # if current child has higher rating than the next one\n            if ratings[i] > ratings[i + 1]:\n                # If the current child's rating is higher than the next child's, update the candies array for the current child.\n                # The new value should be the maximum of its current value and one more than the candies of the next child.\n                # This step ensures that children get more candies than those with a lower rating on their right.\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n\n        return sum(candies)"", '# Test the function with the provided examples\n\ncandy = Solution().candy\n\nratings1 = [1, 0, 2]\nratings2 = [1, 2, 2]\n\noutput1 = candy(ratings1)\noutput2 = candy(ratings2)\n\noutput1, output2']"
"Given n non-negative integers representing an elevation map, compute how much water it can trap after raining.",Calculate trapped rain water,"Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6",1 <= n <= 2 * 10^4; 0 <= height[i] <= 10^5,https://leetcode.com/problems/Trapping-Rain-Water/,Trapping Rain Water,Array and String,"[""class Solution:\n    def trap(self, height: list[int]) -> int:\n        if not height:\n            return 0\n\n        # init two pointers (left and right)\n        left = 0\n        right = len(height) - 1\n\n        # init left_max and right_max to keep track of the max height on the left and right side of the current pointer\n        left_max, right_max = height[left], height[right]\n\n        # total water trapped\n        total = 0\n\n        # while left and right pointers haven't crossed each other\n        while left < right:\n            # if left height is less than right height, then the water trapped at left is\n            # determined by left_max (since the right wall is higher than left wall)\n            if height[left] < height[right]:\n                left += 1\n                left_max = max(left_max, height[left])\n                total += left_max - height[left]\n            # else the water trapped at right is determined by right_max (since the left wall is higher than right wall)\n            else:\n                right -= 1\n                right_max = max(right_max, height[right])\n                total += right_max - height[right]\n\n        return total"", '# O(n) time and O(1) space\n\ntrap = Solution().trap\n\nexample1 = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nexample2 = [4, 2, 0, 3, 2, 5]\n\nresult1 = trap(example1)\nresult2 = trap(example2)\n\nresult1, result2']"
"Given a roman numeral, convert it to an integer.",Convert Roman numeral to integer,Input: s = 'III' Output: 3; Input: s = 'LVIII' Output: 58; Input: s = 'MCMXCIV' Output: 1994.,"1 <= s.length <= 15; s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M'); s is a valid roman numeral in the range [1, 3999].",https://leetcode.com/problems/Roman-to-Integer/,Roman to Integer,Array and String,"['class Solution:\n    def romanToInt(self, s: str) -> int:\n        # Mapping of Roman numerals to integers\n        roman_map = {""I"": 1, ""V"": 5, ""X"": 10, ""L"": 50, ""C"": 100, ""D"": 500, ""M"": 1000}\n\n        total = 0\n        prev_val = 0\n\n        for char in reversed(s):\n            # get the integer value of the roman numeral\n            val = roman_map[char]\n\n            # if the current value is less than the previous value, subtract it\n            # we are in a case like IV (4) or IX (9)\n            if val < prev_val:\n                total -= val\n            else:\n                total += val\n\n            # update the previous value for the next iteration\n            prev_val = val\n\n        return total', '# Test the function with the given examples\n\nromanToInt = Solution().romanToInt\n\nprint(romanToInt(""III""))  # Output: 3\nprint(romanToInt(""LVIII""))  # Output: 58\nprint(romanToInt(""MCMXCIV""))  # Output: 1994']"
What are the time and space complexities of the intToRoman method?,Analyze intToRoman complexity,"Input: 1994, Output: 'MCMXCIV'",Input number must be between 1 and 3999.,https://leetcode.com/problems/Integer-to-Roman/,Integer to Roman,Array and String,"['class Solution:\n    def intToRoman(self, num: int) -> str:\n        # List of tuples with Roman numerals and their corresponding values\n        roman_numerals: list[tuple[str, int]] = [\n            (""M"", 1000),\n            (""CM"", 900),\n            (""D"", 500),\n            (""CD"", 400),\n            (""C"", 100),\n            (""XC"", 90),\n            (""L"", 50),\n            (""XL"", 40),\n            (""X"", 10),\n            (""IX"", 9),\n            (""V"", 5),\n            (""IV"", 4),\n            (""I"", 1),\n        ]\n\n        roman_str: str = """"\n\n        for roman, value in roman_numerals:\n            # Count how many times the Roman numeral can fit into num\n            count = num // value\n            if count != 0:\n                # Append the Roman numeral count times\n                roman_str += roman * count\n                # Reduce num\n                num -= value * count\n\n            # Break the loop if num becomes 0\n            if num == 0:\n                break\n\n        return roman_str\n\n\n# Example usage\nsolution = Solution()\nprint(solution.intToRoman(58))  # Output: ""LVIII""\nprint(solution.intToRoman(1994))  # Output: ""MCMXCIV""']"
What is the time and space complexity of the function `lengthOfLastWord`?,Analyze time and space complexity,Input: 'Hello World' -> Output: 5,n is the length of the input string.,https://leetcode.com/problems/Length-of-Last-Word/,Length of Last Word,Array and String,"['class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        # Splitting the string into words\n        words = s.split()\n\n        # Returning the length of the last word\n        return len(words[-1])\n\n\n# Test cases from the examples\ntest_cases = [""Hello World"", ""   fly me   to   the moon  "", ""luffy is still joyboy""]\n\n# Defining the function\nlengthOfLastWord = Solution().lengthOfLastWord\n\n# Applying the function to each test case\nresults = [lengthOfLastWord(tc) for tc in test_cases]\nresults']"
"Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string.",Longest common prefix finder,"Input: strs = [""flower"",""flow"",""flight""] Output: ""fl""; Input: strs = [""dog"",""racecar"",""car""] Output: """"",1 <= strs.length <= 200; 0 <= strs[i].length <= 200; strs[i] consists of only lowercase English letters.,https://leetcode.com/problems/Longest-Common-Prefix/,Longest Common Prefix,Array and String,"['class Solution:\n    def longestCommonPrefix(self, strs: list[str]) -> str:\n        if not strs:\n            return """"\n        # Find the shortest string in the list\n        shortest = min(strs, key=len)\n        # Initialize the longest common prefix as the shortest string\n        prefix = shortest\n        \n        # Loop through the list of strings\n        for s in strs:\n            # While the prefix is not empty and not a prefix of the current string\n            while prefix and not s.startswith(prefix):\n                # Remove the last character from the prefix\n                prefix = prefix[:-1]\n        # Return the longest common prefix\n        return prefix', 'longestCommonPrefix = Solution().longestCommonPrefix\n\nprint(longestCommonPrefix([""flower"", ""flow"", ""flight""]))  # Output: ""fl""\nprint(longestCommonPrefix([""dog"", ""racecar"", ""car""]))     # Output: """"']"
"Given a string `s`, reverse the order of the words and return it with single spaces, removing any leading or trailing spaces.",Reverse words in string,"Input: `s = ""the sky is blue""` Output: `""blue is sky the""`","1 <= s.length <= 104; s contains English letters, digits, and spaces; at least one word in s.",https://leetcode.com/problems/Reverse-Words-in-a-String/,Reverse Words in a String,Array and String,"['class Solution:\n    def reverseWords(self, s: str) -> str:\n        # convert the words into a list of characters\n        chars = list(s)\n\n        # reverse the characters in the entire list\n        self.reverseCharacters(chars, 0, len(chars) - 1)\n\n        # now we\'ll make the words forward again by reversing each word\'s characters\n\n        # we hold the index of the *start* of the current word as we look for the end of the current word\n        current_word_start_index = 0\n\n        for i in range(len(chars) + 1):\n            # found the end of the current word!\n            if (i == len(chars)) or (chars[i] == "" ""):\n                # if we haven\'t exhausted the string our next word\'s start is one character ahead\n                self.reverseCharacters(chars, current_word_start_index, i - 1)\n                current_word_start_index = i + 1\n\n        # remove leading, trailing and multiple spaces\n        return self.trimSpaces(chars)\n\n    def reverseCharacters(\n        self, chars: list[str], left_index: int, right_index: int\n    ) -> list[str]:\n        # walk towards the middle, from both sides\n        while left_index < right_index:\n            # swap the left and right characters\n            chars[left_index], chars[right_index] = (\n                chars[right_index],\n                chars[left_index],\n            )\n            # move towards the middle\n            left_index += 1\n            right_index -= 1\n\n        return chars\n\n    def trimSpaces(self, chars: list[str]) -> str:\n        # remove leading, trailing and duplicate spaces\n        new_chars = []\n        in_word = False\n\n        for char in chars:\n            if char != "" "":\n                new_chars.append(char)\n                in_word = True\n            elif in_word:\n                # add a space between words\n                new_chars.append(char)\n                in_word = False\n\n        # remove trailing spaces, if any\n        if new_chars and new_chars[-1] == "" "":\n            new_chars.pop()\n\n        return """".join(new_chars)\n\n    def reverse_words(self, s: str) -> str:\n        return "" "".join(reversed(s.split()))\n        # return \' \'.join(s.split()[::-1])']"
What are the time and space complexities of the Zigzag Conversion algorithm?,Zigzag Conversion complexity analysis,"Input: 'PAYPALISHIRING', numRows = 3; Output: 'PAHNAPLSIIGYIR'",numRows must be a positive integer.,https://leetcode.com/problems/Zigzag-Conversion/,Zigzag Conversion,Array and String,"['class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        # edge cases - if there is only one row or the string is shorter than the number of rows\n        if numRows == 1 or numRows >= len(s):\n            return s\n\n        # create a list of strings for each row\n        rows = [""""] * numRows\n\n        # keep track of which row we are on\n        current_row = 0\n\n        # keep track of which direction we are going\n        going_down = False\n\n        # iterate through the string\n        for c in s:\n            # add the character to the current row\n            rows[current_row] += c  # rows[0] = rows[0] + c - string concatenation\n\n            # if we are on the first or last row, change direction\n            if current_row == 0 or current_row == numRows - 1:\n                going_down = not going_down\n\n            # increment or decrement the current row\n            current_row += 1 if going_down else -1\n\n        # return the joined rows\n        return """".join(rows)', '# Test the solution with the provided examples\nsol = Solution()\n\n# Example 1\ns1 = ""PAYPALISHIRING""\nnumRows1 = 3\noutput1 = sol.convert(s1, numRows1)\n\n# Example 2\ns2 = ""PAYPALISHIRING""\nnumRows2 = 4\noutput2 = sol.convert(s2, numRows2)\n\n# Example 3\ns3 = ""A""\nnumRows3 = 1\noutput3 = sol.convert(s3, numRows3)\n\noutput1, output2, output3']"
"Given two strings `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of haystack.",Find first occurrence index,"Input: haystack = ""sadbutsad"", needle = ""sad""; Output: 0. Input: haystack = ""leetcode"", needle = ""leeto""; Output: -1.","1 <= haystack.length, needle.length <= 104; haystack and needle consist of only lowercase English characters.",https://leetcode.com/problems/Find-the-Index-of-the-First-Occurrence-in-a-String/,Find the Index of the First Occurrence in a String,Array and String,"['class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        # Return 0 if needle is an empty string\n        if not needle:\n            return 0\n\n        # Check each possible starting position in haystack\n        for i in range(len(haystack) - len(needle) + 1):\n            # If the substring from the current position matches needle, return the position\n            if haystack[i : i + len(needle)] == needle:\n                return i\n\n        # If needle is not found, return -1\n        return -1', '# Test cases from the examples\nstrStr = Solution().strStr\n\ntest_case_1 = strStr(""sadbutsad"", ""sad"")\ntest_case_2 = strStr(""leetcode"", ""leeto"")\n\ntest_case_1, test_case_2']"
What is the time and space complexity of the `full_justify` function?,Time and space complexity analysis,"Input: words = ['This', 'is', 'an', 'example'], maxWidth = 16; Output: ['This    is    an', 'example']","n is the number of words, maxWidth is the maximum width of a line.",https://leetcode.com/problems/Text-Justification/,Text Justification,Array and String,"['class Solution:\n    def fullJustify(self, words: list[str], maxWidth: int) -> list[str]:\n        # Initializing three variables:\n        # \'result\' to store the final output as a list of justified strings.\n        # \'current_line\' to hold the words of the current line being processed.\n        # \'number_of_letters\' to track the number of non-space characters in the current line.\n        result, current_line, number_of_letters = [], [], 0\n\n        # Iterating over each word in the input list \'words\'.\n        for w in words:\n            # Checking if adding the current word to \'current_line\' would exceed \'maxWidth\'. If yes, this can form a line\n            # The total length includes the word itself (len(w)) and the spaces between words (len(current_line)).\n            if number_of_letters + len(w) + len(current_line) > maxWidth:\n                # For lines with more than one word\n                if len(current_line) > 1:\n                    # Calculate the total number of spaces needed and the number of gaps between words.\n                    total_spaces = maxWidth - number_of_letters\n                    gaps = len(current_line) - 1\n                    base_space, extra = divmod(total_spaces, gaps)\n\n                    # Distribute the spaces between words.\n                    for i in range(len(current_line) - 1):\n                        current_line[i] += \' \' * (base_space + (i < extra))\n                else:\n                    # For lines with a single word, pad the word to the right to meet maxWidth.\n                    current_line[0] = current_line[0].ljust(maxWidth)\n\n                # Joining the words with the added spaces to form a justified line.\n                # Then, adding this line to \'result\'.\n                result.append("""".join(current_line))\n\n                # Resetting \'current_line\' and \'number_of_letters\' for the next line.\n                current_line, number_of_letters = [], 0\n\n            # Adding the current word to \'current_line\' and updating \'number_of_letters\'.\n            current_line.append(w)\n            number_of_letters += len(w)\n\n        # Handling the last line: it should be left-justified.\n        # Joining the remaining words in \'current_line\' with a single space and justifying it to \'maxWidth\'.\n        return result + ["" "".join(current_line).ljust(maxWidth)]', '# Test the function with the provided examples\n\nfull_justify = Solution().fullJustify\n\nexample1 = [""This"", ""is"", ""an"", ""example"", ""of"", ""text"", ""justification.""]\nexample2 = [""What"", ""must"", ""be"", ""acknowledgment"", ""shall"", ""be""]\nexample3 = [\n    ""Science"",\n    ""is"",\n    ""what"",\n    ""we"",\n    ""understand"",\n    ""well"",\n    ""enough"",\n    ""to"",\n    ""explain"",\n    ""to"",\n    ""a"",\n    ""computer."",\n    ""Art"",\n    ""is"",\n    ""everything"",\n    ""else"",\n    ""we"",\n    ""do"",\n]\n\noutput1 = full_justify(example1, 16)\noutput2 = full_justify(example2, 16)\noutput3 = full_justify(example3, 20)\n\noutput1, output2, output3']"
"Given a string s, return true if it is a palindrome after converting to lowercase and removing non-alphanumeric characters, otherwise return false.",Check if string is palindrome,"Input: s = 'A man, a plan, a canal: Panama' Output: true; Input: s = 'race a car' Output: false; Input: s = ' ' Output: true",1 <= s.length <= 2 * 10^5; s consists only of printable ASCII characters.,https://leetcode.com/problems/Valid-Palindrome/,Valid Palindrome,Two Pointers,"['class Solution:\n    # two pointers - O(n) time, O(1) space\n    def isPalindrome(self, s: str) -> bool:\n        left, right = 0, len(s) - 1\n\n        while left < right:\n            while left < right and not s[left].isalnum():\n                left += 1\n            while left < right and not s[right].isalnum():\n                right -= 1\n\n            if s[left].lower() != s[right].lower():\n                return False\n\n            left += 1\n            right -= 1\n\n        return True']"
"Given two strings `s` and `t`, return `true` if `s` is a `subsequence` of `t`, or `false` otherwise. A subsequence is formed by deleting some characters from `t` without disturbing the order.",Check if subsequence exists,"Input: s = ""abc"", t = ""ahbgdc""; Output: true. Input: s = ""axc"", t = ""ahbgdc""; Output: false.","0 <= s.length <= 100, 0 <= t.length <= 10^4, s and t consist only of lowercase English letters.",https://leetcode.com/problems/Is-Subsequence/,Is Subsequence,Two Pointers,"['class Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        if not s:\n            return True  # an empty string is a subsequence of any string\n\n        i = 0\n        j = 0\n\n        while j < len(t):\n            if t[j] == s[i]:\n                i += 1\n                if i == len(s):\n                    return True\n\n            # move j forward\n            j += 1\n\n        # end of t reached but not all of s was found\n        return False', '# Test the function with the provided examples\n\nisSubsequence = Solution().isSubsequence\n\ntest_case_1 = isSubsequence(""abc"", ""ahbgdc"")\ntest_case_2 = isSubsequence(""axc"", ""ahbgdc"")\n\ntest_case_1, test_case_2']"
What are the time and space complexities of the implemented function using a two-pointer approach?,Analyze time and space complexity,"Input: [1, 2, 3, 4]; Output: Time Complexity: O(n), Space Complexity: O(1)",Input array length n must be non-negative.,https://leetcode.com/problems/Container-with-Most-Water/,Container with Most Water,Two Pointers,"['class Solution:\n    def maxArea(self, height: list[int]) -> int:\n        # initialize two pointers\n        left, right = 0, len(height) - 1\n\n        # initialize max area\n        max_area = 0\n\n        # loop while left < right\n        while left < right:\n            # calculate area - [min of left and right (determined by the short one)] * [distance between them]\n            current_area = min(height[left], height[right]) * (right - left)\n\n            # update max area\n            max_area = max(max_area, current_area)\n\n            # move the pointer that is shorter\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return max_area', '# Test the function with the provided examples\n\nmax_area = Solution().maxArea\n\nexample1 = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nexample2 = [1, 1]\n\nmax_area_example1 = max_area(example1)\nmax_area_example2 = max_area(example2)\n\nmax_area_example1, max_area_example2']"
"Given a 1-indexed sorted array of integers, find two distinct indices such that the numbers at those indices add up to a specific target. Return the indices as an array, with each index incremented by one.",Find indices of two numbers,"Input: numbers = [2,7,11,15], target = 9; Output: [1,2]",2 <= numbers.length <= 3 * 10^4; -1000 <= numbers[i] <= 1000; -1000 <= target <= 1000; exactly one solution exists.,https://leetcode.com/problems/Two-Sum-II---Input-Array-Is-Sorted/,Two Sum II - Input Array Is Sorted,Two Pointers,"['class Solution:\n    # solve the problem in O(n) time and O(1) space\n    def twoSum(self, number: list[int], target: int) -> list[int]:\n        # init two pointers\n        left = 0\n        right = len(number) - 1\n\n        # iterate while left < right\n        while left < right:\n            current_sum = number[left] + number[right]\n\n            if current_sum == target:\n                # return the indices, add 1 to each index since the indices are 1-based\n                return [left + 1, right + 1]\n\n            elif current_sum < target:\n                # if the sum is less than the target, increment the left pointer\n                left += 1\n\n            else:\n                # if the sum is greater than the target, decrement the right pointer\n                right -= 1\n\n        # if no solution is found, return [-1, -1]\n        return [-1, -1]', '# Testing the function with given examples\nsol = Solution()\nprint(sol.twoSum([2, 7, 11, 15], 9))  # Example 1\nprint(sol.twoSum([2, 3, 4], 6))  # Example 2\nprint(sol.twoSum([-1, 0], -1))  # Example 3']"
How to find all unique triplets in an array that sum to zero using a two-pointer approach?,3Sum problem solution,"Input: nums = [-1, 0, 1, 2, -1, -4], Output: [[-1, -1, 2], [-1, 0, 1]]","The input array can contain both positive and negative integers, and the output should not contain duplicate triplets.",https://leetcode.com/problems/Three-Sum/,Three Sum,Two Pointers,"['class Solution:\n    def threeSum(self, nums: list[int]) -> list[list[int]]:\n        # sort the list\n        nums.sort()\n        \n        # result list\n        result: list[list[int]] = []\n\n        for i in range(len(nums)):\n            # Avoid duplicates for the first number\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            \n            # left and right pointers - left starts at i + 1, right starts at the end of the list\n            left, right = i + 1, len(nums) - 1\n\n            while left < right:\n                # calculate the current sum\n                current_sum = nums[i] + nums[left] + nums[right]\n\n                # if current_sum is less than 0, we need a larger number, move left pointer right\n                if current_sum < 0:\n                    left += 1\n                # if current_sum is greater than 0, we need a smaller number, move right pointer left\n                elif current_sum > 0:\n                    right -= 1\n                else:\n                    # if the sum equals to 0, we found a triplet\n                    result.append([nums[i], nums[left], nums[right]])\n\n                    # Skip duplicates for the second and third numbers\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n\n                    left += 1\n                    right -= 1\n\n        return result', '# Tests\nthree_sums = Solution().threeSum\n\nprint(three_sums([-1, 0, 1, 2, -1, -4]))\nprint(three_sums([0, 1, 1]))\nprint(three_sums([0, 0, 0]))']"
What are the time and space complexities of the happy number problem using the fast-slow pointer technique?,Happy number problem analysis,"Input: 19, Output: True (19 is a happy number)",Input number n must be a positive integer.,https://leetcode.com/problems/Happy-Number/,Happy Number,Two Pointers,"['class Solution:\n    def isHappy(self, n: int) -> bool:\n        """"""Determine if n is a happy number.""""""\n        slow = fast = n\n        while True:\n            slow = self.sum_of_squares(slow)  # Move one step\n            fast = self.sum_of_squares(self.sum_of_squares(fast))  # Move two steps\n            if fast == 1:\n                return True  # Found a happy number\n            if slow == fast:\n                return False  # Detected a cycle, not a happy number\n\n\n    def sum_of_squares(self, n: int) -> int:\n        """"""Return the sum of the squares of the digits of n.""""""\n        total = 0\n        while n > 0:\n            digit = n % 10\n            total += digit ** 2\n            n //= 10\n        return total', '# Test cases\n\nis_happy = Solution().isHappy\n\ntest_numbers = [19, 2, 7, 20, 28, 100, 4]\ntest_results = {num: is_happy(num) for num in test_numbers}\n\ntest_results']"
How to find the longest substring without repeating characters in a given string `s` using the sliding window technique?,Longest substring without repeating characters,Input: 'abcabcbb' Output: 3 (substring 'abc'),The input string `s` can contain any characters.,https://leetcode.com/problems/Longest-Substring-Without-Repeating-Characters/,Longest Substring Without Repeating Characters,Sliding Window,"['class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        char_set = set()\n        max_length = 0\n        start = 0\n\n        for end in range(len(s)):\n            while s[end] in char_set:\n                char_set.remove(s[start])\n                start += 1\n            char_set.add(s[end])\n            max_length = max(max_length, end - start + 1)\n\n        return max_length', '# Testing the function with the provided examples\n\nlength_of_longest_substring = Solution().lengthOfLongestSubstring\n\nexample1 = ""abcabcbb""  # Expected output: 3\nexample2 = ""bbbbb""  # Expected output: 1\nexample3 = ""pwwkew""  # Expected output: 3\n\nlength_example1 = length_of_longest_substring(example1)\nlength_example2 = length_of_longest_substring(example2)\nlength_example3 = length_of_longest_substring(example3)\n\nlength_example1, length_example2, length_example3']"
Find the smallest substring in string `s` that contains all characters of string `t` using the sliding window technique.,Minimum Window Substring problem,"Input: s = 'ADOBECODEBANC', t = 'ABC' -> Output: 'BANC'; Input: s = 'a', t = 'a' -> Output: 'a'; Input: s = 'a', t = 'aa' -> Output: ''","Time complexity should be O(m + n), where m is the length of s and n is the length of t.",https://leetcode.com/problems/Minimum-Window-Substring/,Minimum Window Substring,Sliding Window,"['def min_window_substring(s: str, t: str) -> str:\n    if not t or not s:\n        return """"\n\n    # Dictionary which keeps a count of all the unique characters in t.\n    dict_t = {}\n    for character in t:\n        dict_t[character] = dict_t.get(character, 0) + 1\n\n    # Number of unique characters in t, which need to be present in the desired window.\n    required = len(dict_t)\n\n    # Left and Right pointer\n    l, r = 0, 0\n\n    # Formed is used to keep track of how many unique characters in t are present in the current window in its desired frequency.\n    # e.g. if t is ""AABC"" then the window must have two A\'s, one B and one C. Thus formed would be = 3 when all these conditions are met.\n    formed = 0\n\n    # Dictionary which keeps a count of all the unique characters in the current window.\n    window_counts = {}\n\n    # ans tuple of the form (window length, left, right)\n    ans = float(""inf""), None, None\n\n    while r < len(s):\n        # Add one character from the right to the window\n        character = s[r]\n        window_counts[character] = window_counts.get(character, 0) + 1\n\n        # If the frequency of the current character added equals to the desired count in t then increment the formed count by 1.\n        if character in dict_t and window_counts[character] == dict_t[character]:\n            formed += 1\n\n        # Try and contract the window till the point where it ceases to be \'desirable\'.\n        while l <= r and formed == required:\n            character = s[l]\n\n            # Save the smallest window until now.\n            if r - l + 1 < ans[0]:\n                ans = (r - l + 1, l, r)\n\n            # The character at the position pointed by the `Left` pointer is no longer a part of the window.\n            window_counts[character] -= 1\n            if character in dict_t and window_counts[character] < dict_t[character]:\n                formed -= 1\n\n            # Move the left pointer ahead, this would help to look for a new window.\n            l += 1\n\n        # Keep expanding the window once we are done contracting.\n        r += 1\n    return """" if ans[0] == float(""inf"") else s[ans[1] : ans[2] + 1]\n\n\n# Test the function with the provided examples\nexample1 = min_window_substring(""ADOBECODEBANC"", ""ABC"")  # Expected: ""BANC""\nexample2 = min_window_substring(""a"", ""a"")  # Expected: ""a""\nexample3 = min_window_substring(""a"", ""aa"")  # Expected: """"\n\nexample1, example2, example3']"
What is the time and space complexity for finding concatenated substrings with permutations of given words?,Analyze time and space complexity,"Input: s = 'barfoothefoobarman', words = ['foo', 'bar']
Output: [0, 9]",N is the length of string s; word_count is the number of words in the list.,https://leetcode.com/problems/Substring-with-Concatenation-of-All-Words/,Substring with Concatenation of All Words,Sliding Window,"['class Solution:\n    # solve the problem using a sliding window\n    def findSubstring(self, s: str, words: list[str]) -> list[int]:\n        if not words or not s:\n            return []\n\n        word_length = len(words[0])\n        word_frequency = {}\n\n        # Create a frequency map for the words\n        for word in words:\n            word_frequency[word] = word_frequency.get(word, 0) + 1\n\n        result = []\n\n        # Iterate over the string in word_length-sized steps, starting at different indices\n        for i in range(word_length):\n            left = i  # Left boundary of the sliding window\n            count = 0  # Count of words matched in the current window\n            current_window_count = {}  # Counts words in the current window\n\n            # Slide the window over the string\n            for j in range(i, len(s) - word_length + 1, word_length):\n                word = s[j : j + word_length]\n                if word in word_frequency:\n                    current_window_count[word] = current_window_count.get(word, 0) + 1\n                    count += 1\n\n                    # Slide the left boundary to the right to remove excess words\n                    while current_window_count[word] > word_frequency[word]:\n                        left_word = s[left : left + word_length]\n                        current_window_count[left_word] -= 1\n                        left += word_length\n                        count -= 1\n\n                    # Check if the current window matches the words array\n                    if count == len(words):\n                        result.append(left)\n                else:\n                    current_window_count.clear()\n                    count = 0\n                    left = j + word_length\n\n        return result', '# Example 1\n\nfindSubstring = Solution().findSubstring\n\ns1 = ""barfoothefoobarman""\nwords1 = [""foo"", ""bar""]\nprint(findSubstring(s1, words1))  # Expected output: [0, 9]\n\n# Example 2\ns2 = ""wordgoodgoodgoodbestword""\nwords2 = [""word"", ""good"", ""best"", ""word""]\nprint(findSubstring(s2, words2))  # Expected output: []\n\n# Example 3\ns3 = ""barfoofoobarthefoobarman""\nwords3 = [""bar"", ""foo"", ""the""]\nprint(findSubstring(s3, words3))  # Expected output: [6, 9, 12]']"
"Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.",Minimum size subarray sum,"Input: target = 7, nums = [2,3,1,2,4,3] Output: 2; Input: target = 4, nums = [1,4,4] Output: 1; Input: target = 11, nums = [1,1,1,1,1,1,1,1] Output: 0",1 <= target <= 10^9; 1 <= nums.length <= 10^5; 1 <= nums[i] <= 10^4,https://leetcode.com/problems/Minimum-Size-Subarray-Sum/,Minimum Size Subarray Sum,Sliding Window,"['# Approach 1: Sliding Window (O(n) Time Complexity)\nclass Solution1:\n    def minSubArrayLen(self, target: int, nums: list[int]) -> int:\n        # Length of the input array\n        n = len(nums)\n        # Initialize the minimum length to infinity (to represent a very large number)\n        min_length = float(""inf"")\n        # Initialize the left pointer of the window to 0\n        left = 0\n        # Initialize the current sum of the window to 0\n        current_sum = 0\n\n        # Iterate over the array with the right pointer\n        for right in range(n):\n            # Add the current right element to the window\'s sum\n            current_sum += nums[right]\n\n            # Once the current sum is greater or equal to the target, try to shrink the window\n            while current_sum >= target:\n                # Update the minimum length if the current window is smaller\n                min_length = min(min_length, right - left + 1)\n                # Subtract the leftmost element from the sum as we are about to move the left pointer to the right\n                current_sum -= nums[left]\n                # Move the left pointer to the right, effectively shrinking the window\n                left += 1\n\n        # If min_length is still infinity, it means no valid subarray was found. Return 0 in this case.\n        # Otherwise, return the minimum length found.\n        return min_length if min_length != float(""inf"") else 0\n\n\n# Example usage\nsolution1 = Solution1()\nprint(solution1.minSubArrayLen(7, [2, 3, 1, 2, 4, 3]))  # Output: 2']"
"Given two strings `ransomNote` and `magazine`, return `true` if `ransomNote` can be constructed using letters from `magazine`, otherwise return `false`. Each letter in `magazine` can only be used once.",Ransom note construction check,"Input: ransomNote = ""a"", magazine = ""b""; Output: false. Input: ransomNote = ""aa"", magazine = ""ab""; Output: false. Input: ransomNote = ""aa"", magazine = ""aab""; Output: true.","1 <= ransomNote.length, magazine.length <= 10^5; ransomNote and magazine consist of lowercase English letters.",https://leetcode.com/problems/Ransom-Note/,Ransom Note,Hashmap,"['class Solution:\n    # O(n) time complexity: iterate over both strings once\n    # O(n) space complexity: store all chars of magazine in dict\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        # create a dictionary to store the freq of each char in the magazine\n        magazine_chars = {}\n\n        for char in magazine:\n            if char in magazine_chars:\n                # Increment the count if the character is already in the dictionary\n                magazine_chars[char] += 1\n            else:\n                # Initialize the count to 1 for new characters\n                magazine_chars[char] = 1\n\n        # check if the ransom note can be constructed\n        for char in ransomNote:\n            # Return False if the character is not in the magazine or has been used up\n            if char not in magazine_chars or magazine_chars[char] == 0:\n                return False\n            # Decrement the count of the character used\n            magazine_chars[char] -= 1\n\n         # Return True if all characters in ransomNote can be constructed from the magazine\n        return True', '# Testing the function with the provided examples\n\ncan_construct = Solution().canConstruct\n\nexample1 = can_construct(""a"", ""b"")  # Expected: False\nexample2 = can_construct(""aa"", ""ab"")  # Expected: False\nexample3 = can_construct(""aa"", ""aab"")  # Expected: True\n\nexample1, example2, example3']"
"Given two strings `s` and `t`, determine if they are isomorphic. Two strings are isomorphic if the characters in `s` can be replaced to get `t`, with all occurrences of a character replaced consistently and no two characters mapping to the same character.",Check if strings are isomorphic,"Input: s = ""egg"", t = ""add""; Output: true. Input: s = ""foo"", t = ""bar""; Output: false. Input: s = ""paper"", t = ""title""; Output: true.",1 <= s.length <= 5 * 10^4; t.length == s.length; s and t consist of any valid ascii character.,https://leetcode.com/problems/Isomorphic-Strings/,Isomorphic Strings,Hashmap,"['class Solution:\n    # O(n) time complexity: iterate over both strings once\n    # O(m) space complexity: m = number of unique characters in s - Given that there are only 256 ASCII characters, m is constant and can be considered O(1)\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        # First, check if s and t are of equal length. If not, they cannot be isomorphic.\n        if len(s) != len(t):\n            return False\n\n        # char_map will store the mapping of characters from s to t.\n        char_map = {}\n        # mapped_chars will keep track of characters in t that are already mapped to characters in s.\n        mapped_chars = set()\n\n        # Iterate over characters of both s and t simultaneously.\n        for char_s, char_t in zip(s, t):\n            # If char_s is not already mapped, map it to char_t.\n            if char_s not in char_map:\n                # If char_t is already mapped to some other character in s, then s and t are not isomorphic.\n                if char_t in mapped_chars:\n                    return False\n                # Map char_s to char_t and add char_t to the set of mapped characters.\n                char_map[char_s] = char_t\n                mapped_chars.add(char_t)\n            # If char_s is already mapped, check for consistency in mapping. If inconsistent, return False.\n            elif char_map[char_s] != char_t:\n                return False\n\n        # If all checks pass, s and t are isomorphic.\n        return True', 'is_isomorphic = Solution().isIsomorphic\n\ntest_cases = [(""egg"", ""add""), (""foo"", ""bar""), (""paper"", ""title"")]\nresults = [is_isomorphic(s, t) for s, t in test_cases]\nresults']"
"Given a pattern and a string s, determine if s follows the same pattern with a bijection between letters and non-empty words.",Check string pattern match,"Input: pattern = 'abba', s = 'dog cat cat dog' Output: true; Input: pattern = 'abba', s = 'dog cat cat fish' Output: false; Input: pattern = 'aaaa', s = 'dog cat cat dog' Output: false",1 <= pattern.length <= 300; pattern contains only lower-case English letters; 1 <= s.length <= 3000; s contains only lowercase English letters and spaces; s does not contain leading or trailing spaces; All words in s are separated by a single space.,https://leetcode.com/problems/Word-Pattern/,Word Pattern,Hashmap,"[""class Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        # Split the string into words\n        words = s.split()\n\n        # If the number of elements in pattern and words don't match, return False\n        if len(pattern) != len(words):\n            return False\n\n        # Dictionary to store the mapping of pattern characters to words\n        mapping = {}\n\n        # Iterate over the pattern characters and corresponding words\n        for char, word in zip(pattern, words):\n            # Check if the character is already mapped to a different word,\n            # or if the word is mapped to a different character\n            if (char in mapping and mapping[char] != word) or \\\n                    (word in mapping.values() and char not in mapping):\n                return False\n\n            # Map the character to the word\n            mapping[char] = word\n\n        # If all checks pass, return True\n        return True"", '# Test the function with the provided examples\nword_pattern = Solution().wordPattern\n\ntest_cases = [\n    (""abba"", ""dog cat cat dog""),  # Example 1\n    (""abba"", ""dog cat cat fish""),  # Example 2\n    (""aaaa"", ""dog cat cat dog"")   # Example 3\n]\n\nresults = [word_pattern(pattern, s) for pattern, s in test_cases]\nresults']"
What is the time and space complexity of the isAnagram function?,Analyze isAnagram complexity,"Input: s = 'listen', t = 'silent' -> Output: True",Strings s and t are of equal length.,https://leetcode.com/problems/Valid-Anagram/,Valid Anagram,Hashmap,"['class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n\n        count_s, count_t = {}, {}\n\n        for char in s:\n            count_s[char] = count_s.get(char, 0) + 1\n\n        for char in t:\n            count_t[char] = count_t.get(char, 0) + 1\n\n        return count_s == count_t', '# Test Cases\n\nsolution = Solution()\n\n# Example 1\nassert solution.isAnagram(""anagram"", ""nagaram"") == True\nprint(""Example 1 passed"")\nassert solution.isAnagram(""rat"", ""car"") == False\nprint(""Example 2 passed"")']"
What is the time and space complexity of the algorithm for grouping anagrams?,Analyze time and space complexity,"Input: ['eat', 'tea', 'tan', 'ate', 'nat', 'bat'] Output: [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]","N is the number of strings, K is the maximum length of a string.",https://leetcode.com/problems/Group-Anagrams/,Group Anagrams,Hashmap,"[""class Solution:\n    def groupAnagrams(self, strs: list[str]) -> list[list[str]]:\n        # Dictionary to hold sorted string as key and list of anagrams as value\n        anagrams: dict[str, list[str]] = {}\n        \n        # Iterate through each string in strs\n        for s in strs:\n            # Sort the string\n            sorted_s = ''.join(sorted(s))\n            \n            # If sorted string is not in dictionary, add it with empty list as value\n            if sorted_s not in anagrams:\n                anagrams[sorted_s] = []\n            \n            # Append the string to the list of anagrams\n            anagrams[sorted_s].append(s)\n            \n        # Return the values of the dictionary\n        return list(anagrams.values())"", '# Test the function with the provided examples\n\ngroup_anagrams = Solution().groupAnagrams\n\nexample1 = [""eat"", ""tea"", ""tan"", ""ate"", ""nat"", ""bat""]\nexample2 = [""""]\nexample3 = [""a""]\n\nresult1 = group_anagrams(example1)\nresult2 = group_anagrams(example2)\nresult3 = group_anagrams(example3)\n\nresult1, result2, result3']"
"Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to target. Each input has exactly one solution, and the same element cannot be used twice.",Find two sum indices,"Input: nums = [2,7,11,15], target = 9; Output: [0,1]",2 <= nums.length <= 10^4; -10^9 <= nums[i] <= 10^9; -10^9 <= target <= 10^9; Only one valid answer exists.,https://leetcode.com/problems/Two-Sum/,Two Sum,Hashmap,"['', 'class Solution:\n    # Solve with O(n) time complexity, O(n) space complexity\n    def twoSum(self, nums: list[int], target: int) -> list[int]:\n        # Create a dictionary to store the index of each number\n        num_to_index = {}\n\n        # Iterate through the list of numbers\n        for i, num in enumerate(nums):\n            # Calculate the number needed to reach the target\n            complement = target - num\n\n            # If the needed number is in the dictionary, return the indices\n            if complement in num_to_index:\n                return [num_to_index[complement], i]\n\n            # Add the current number to the dictionary\n            num_to_index[num] = i', '# Test\ntwo_sum = Solution().twoSum\n\n# Example 1\nprint(two_sum([2, 7, 11, 15], 9))\n\n# Example 2\nprint(two_sum([3, 2, 4], 6))\n\n# Example 3\nprint(two_sum([3, 3], 6))']"
What is the time and space complexity of the solution to the 'Contains Duplicate II' problem?,Analyze time and space complexity,"Input: nums = [1,2,3,1], k = 3; Output: True",n is the length of nums; k is the maximum distance between duplicate values.,https://leetcode.com/problems/Contains-Duplicate-II/,Contains Duplicate II,Hashmap,"['class Solution:\n    def containsNearbyDuplicate(self, nums: list[int], k: int) -> bool:\n        # init a dict to store the index of each number encountered\n        num_to_index = {}\n\n        # iterate through the list\n        for i, num in enumerate(nums):\n            # if the number is already in the dict and the difference between the current index and the previous index is less than or equal to k\n            if num in num_to_index and i - num_to_index[num] <= k:\n                return True\n            # update the index of the number\n            num_to_index[num] = i\n\n        # if no such pair of numbers found\n        return False', '# Test the function with the provided examples\n\ncontains_nearby_duplicate = Solution().containsNearbyDuplicate\n\ntest_cases = [\n    ([1, 2, 3, 1], 3),  # Example 1\n    ([1, 0, 1, 1], 1),  # Example 2\n    ([1, 2, 3, 1, 2, 3], 2)  # Example 3\n]\n\n# Execute test cases\nresults = [contains_nearby_duplicate(nums, k) for nums, k in test_cases]\nresults']"
"Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence. The algorithm must run in O(n) time.",Longest consecutive sequence length,"Input: nums = [100,4,200,1,3,2] Output: 4; Input: nums = [0,3,7,2,5,8,4,6,0,1] Output: 9",0 <= nums.length <= 10^5; -10^9 <= nums[i] <= 10^9,https://leetcode.com/problems/Longest-Consecutive-Sequence/,Longest Consecutive Sequence,Hashmap,"['class Solution:\n    # O(n) time complexity: iterate through nums once\n    # O(n) space complexity: set of nums\n    def longestConsecutive(self, nums: list[int]) -> int:\n        if not nums:\n            return 0\n\n        # insert all numbers into a set\n        # Convert nums into a set (nums_set) to remove duplicates and allow for O(1) existence checks.\n        nums_set = set(nums)\n\n        # initialize longest_streak\n        longest_streak = 0\n\n        # iterate through the set\n        for num in nums_set:\n            # for each number, check if it is the start of a sequence\n            if num - 1 not in nums_set:\n                current_num = num\n                current_streak = 1\n                # explore the sequence - keep checking an incrementing the current number\n                while current_num + 1 in nums_set:\n                    current_num += 1\n                    current_streak += 1\n\n                # update the longest_streak\n                longest_streak = max(longest_streak, current_streak)\n\n        return longest_streak', '# Testing\nlongestConsecutive = Solution().longestConsecutive\n\n# Example 1\n\nnums1 = [100, 4, 200, 1, 3, 2]\nprint(longestConsecutive(nums1))  # Output: 4\n\n# Example 2\nnums2 = [0, 3, 7, 2, 5, 8, 4, 6, 0, 1]\nprint(longestConsecutive(nums2))  # Output: 9']"
"Given a sorted unique integer array nums, return the smallest sorted list of ranges that cover all the numbers in the array exactly.",Return smallest sorted ranges,"Input: nums = [0,1,2,4,5,7] Output: [""0->2"",""4->5"",""7""]",0 <= nums.length <= 20; 2^31 <= nums[i] <= 2^31 - 1; All values of nums are unique; nums is sorted in ascending order.,https://leetcode.com/problems/Summary-Ranges/,Summary Ranges,Intervals,"['class Solution:\n    # O(n) time | O(n) space (for output list) - where n is the length of the input list\n    def summaryRanges(self, nums: list[int]) -> list[str]:\n        if not nums:\n            return []\n\n        ranges: list[str] = []\n\n        # start of the current range\n        start = nums[0]\n        for i in range(1, len(nums)):\n            # if the current number is not consecutive, add the range to the list\n            if nums[i] != nums[i - 1] + 1:\n                # 1. if the range has only one number, add it to the list\n                if start == nums[i - 1]:\n                    ranges.append(str(start))\n                else:\n                    # 2. if the range has more than one number, add the range to the list\n                    ranges.append(f""{start}->{nums[i - 1]}"")\n\n                # update the start of the next range\n                start = nums[i]\n\n        # add the last range\n        # 1. if the range has only one number, add it to the list\n        if start == nums[-1]:\n            ranges.append(str(start))\n        else:\n            # 2. if the range has more than one number, add the range to the list\n            ranges.append(f""{start}->{nums[-1]}"")\n\n        return ranges', '# Test cases\n\nsummary_ranges = Solution().summaryRanges\n\n# Expected: [""0->2"",""4->5"",""7""]\nprint(summary_ranges([0, 1, 2, 4, 5, 7]))\n\n# Expected: [""0"",""2->4"",""6"",""8->9""]\nprint(summary_ranges([0, 2, 3, 4, 6, 8, 9]))']"
What are the time and space complexities of the merge intervals algorithm?,Analyze merge intervals complexity,"Input: [[1,3],[2,6],[8,10],[15,18]]; Output: [[1,6],[8,10],[15,18]]",Consider n intervals where n is a positive integer.,https://leetcode.com/problems/Merge-Intervals/,Merge Intervals,Intervals,"['class Solution:\n    def merge(self, intervals: list[list[int]]) -> list[list[int]]:\n        # sort the intervals by the start value\n        intervals.sort(key=lambda x: x[0])\n\n        merged = []\n        for interval in intervals:\n            # if the list of merged intervals is empty or if the current interval does not overlap with the previous, simply append it.\n            if not merged or merged[-1][1] < interval[0]:\n                merged.append(interval)\n            else:\n                # otherwise, there is overlap, so we merge the current and previous intervals.\n                merged[-1][1] = max(merged[-1][1], interval[1])\n\n        return merged', '# Test cases\n\nmerge = Solution().merge\n\ntest_case1 = [[1, 3], [2, 6], [8, 10], [15, 18]]\ntest_case2 = [[1, 4], [4, 5]]\n\noutput1 = merge(test_case1)\noutput2 = merge(test_case2)\n\noutput1, output2']"
"Given a sorted array of non-overlapping intervals and a new interval, insert the new interval into the array while merging any overlapping intervals.",Insert new interval,"Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]]",0 <= intervals.length <= 10^4; intervals[i].length == 2; 0 <= starti <= endi <= 10^5; newInterval.length == 2; 0 <= start <= end <= 10^5,https://leetcode.com/problems/Insert-Interval/,Insert Interval,Intervals,"['class Solution:\n    # Overall time complexity is O(N) dominated by the merge function\n    # Space complexity is O(N) due to the merged list\n    def insert(self, intervals: list[list[int]], newInterval: list[int]) -> list[list[int]]:\n        # binary search to find the insertion point for the new interval - O(log N)\n        def find_insertion_point():\n            low, high = 0, len(intervals) - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if intervals[mid][0] < newInterval[0]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            return low\n\n        insertion_point = find_insertion_point()\n\n        # Insert the new interval into the list\n        intervals.insert(insertion_point, newInterval)\n\n        # Now, merge overlapping intervals starting from the insertion point\n        return self.merge(intervals)\n\n    def merge(self, intervals: list[list[int]]) -> list[list[int]]:\n        # sort the intervals by the start value\n        intervals.sort(key=lambda x: x[0])\n\n        merged = []\n        for interval in intervals:\n            # if the list of merged intervals is empty or if the current interval does not overlap with the previous, simply append it.\n            if not merged or merged[-1][1] < interval[0]:\n                merged.append(interval)\n            else:\n                # otherwise, there is overlap, so we merge the current and previous intervals.\n                merged[-1][1] = max(merged[-1][1], interval[1])\n\n        return merged', '# Example\nsolution = Solution()\n\n# Example 1\nintervals1 = [[1, 3], [6, 9]]\nnew_interval1 = [2, 5]\nprint(solution.insert(intervals1, new_interval1))\n\n# Example 2\nintervals2 = [[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]]\nnew_interval2 = [4, 8]\nprint(solution.insert(intervals2, new_interval2))']"
What are the time and space complexities of the 'Minimum Number of Arrows to Burst Balloons' algorithm?,Analyze algorithm complexities,"Input: points = [[10,16],[2,8],[1,6],[7,12]]; Output: Time Complexity: O(n log n), Space Complexity: O(log n)",Assume n is the number of balloons.,https://leetcode.com/problems/Minimum-Number-of-Arrows-to-Burst-Balloons/,Minimum Number of Arrows to Burst Balloons,Intervals,"['class Solution:\n    # solve with greedy algorithm - sort by end point\n    def findMinArrowShots(self, points: list[list[int]]) -> int:\n        # sort the balloons by end point -\n        # ensure to place an arrow as far to the right as possible\n        points.sort(key=lambda x: x[1])\n\n        # initialize the arrow count and arrow position\n        arrows = 1\n        arrow_pos = points[0][1]\n\n        # iterate through the balloons\n        for x_start, x_end in points:\n            # if the balloon is not popped by the current arrow\n            if arrow_pos < x_start:\n                # move the arrow to the end of the current balloon\n                arrow_pos = x_end\n                # increment the arrow count\n                arrows += 1\n\n        return arrows', '# Example\nfindMinArrowShots = Solution().findMinArrowShots\n\n# Test cases\ntest_cases = [\n    ([[10, 16], [2, 8], [1, 6], [7, 12]], 2),\n    ([[1, 2], [3, 4], [5, 6], [7, 8]], 4),\n    ([[1, 2], [2, 3], [3, 4], [4, 5]], 2),\n]\n\n# Execute test cases\nresults = []\nfor points, expected in test_cases:\n    result = findMinArrowShots(points)\n    results.append((points, result == expected, expected, result))\n\nresults']"
"Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid based on specific rules for brackets.",Validating parentheses in string,Input: s = '()' Output: true; Input: s = '()[]{}' Output: true; Input: s = '(]' Output: false,1 <= s.length <= 10^4; s consists of parentheses only '()[]{}'.,https://leetcode.com/problems/Valid-Parentheses/,Valid Parentheses,Stack,"[""class Solution:\n    # Time complexity: O(n)\n    # Space complexity: O(n)\n    def isValid(self, s: str) -> bool:\n        # create a stack\n        stack = []\n\n        # create a dictionary to store the pairs\n        pairs = {\n            ')': '(',\n            ']': '[',\n            '}': '{'\n        }\n\n        # iterate through the string\n        for char in s:\n            # if a char is the closing bracket\n            if char in pairs:\n                # pop the topmost element if stack is not empty else assign a dummy value\n                top_element = stack.pop() if stack else '#'\n                # if the top element is not the corresponding opening bracket\n                if pairs[char] != top_element:\n                    return False\n            else:\n                # if the char is an opening bracket, push it to the stack\n                stack.append(char)\n\n        # if the stack is empty, return True as all brackets are closed properly else False\n        return not stack"", '# Test cases\n\nisValid = Solution().isValid\n\ntest_cases = [""()"", ""()[]{}"", ""(]""]\nresults = [isValid(s) for s in test_cases]\nresults']"
"Given an absolute Unix-style file path, convert it to the simplified canonical path according to specific rules regarding slashes and directory references.",Simplify Unix-style file path,"Input: path = ""/home/""
Output: ""/home""
Input: path = ""/../""
Output: ""/""
Input: path = ""/home//foo/""
Output: ""/home/foo""","1 <= path.length <= 3000; path consists of English letters, digits, period '.', slash '/', or '_'; path is a valid absolute Unix path.",https://leetcode.com/problems/Simplify-Path/,Simplify Path,Stack,"[""class Solution:\n    def simplifyPath(self, path: str) -> str:\n        # split the path by '/\n        path = path.split('/')\n\n        # create a stack to store the path\n        stack = []\n\n        # iterate through the path\n        for p in path:\n            # if the path is not empty\n            if p:\n                # if the path is '..'\n                if p == '..':\n                    # pop the last element (go back to the previous directory)\n                    if stack:\n                        stack.pop()\n                # if the path is not '.' (not the current directory)\n                elif p != '.':\n                    # append the path to the stack\n                    stack.append(p)\n\n        # returnd the simplified path\n        return '/' + '/'.join(stack)"", '# Test cases\n\nsimplifyPath = Solution().simplifyPath\n\nprint(simplifyPath(""/home/""))  # Output: ""/home""\nprint(simplifyPath(""/../""))  # Output: ""/""\nprint(simplifyPath(""/home//foo/""))  # Output: ""/home/foo""']"
"Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class with specified methods.",Design a Min Stack,"Input: [""MinStack"",""push"",""push"",""push"",""getMin"",""pop"",""top"",""getMin""], [[],[-2],[0],[-3],[],[],[],[]]; Output: [null,null,null,null,-3,null,0,-2]","2^31 <= val <= 2^31 - 1; At most 3 * 10^4 calls will be made to push, pop, top, and getMin.",https://leetcode.com/problems/Min-Stack/,Min Stack,Stack,"['class MinStack:\n    def __init__(self):\n        # Use two stacks: one to store all values and another to store minimum values\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val):\n        # Push value onto the main stack\n        self.stack.append(val)\n        # If the min_stack is empty or the current value is less than or equal to the current minimum, push it onto the min_stack\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self):\n        # Pop value from the main stack\n        val = self.stack.pop()\n        # If the popped value is the current minimum, also pop it from the min_stack\n        if val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self):\n        # Return the top element of the main stack\n        return self.stack[-1]\n\n    def getMin(self):\n        # Return the top element of the min_stack, which is the current minimum\n        return self.min_stack[-1]\n\n\n# Example usage\nminStack = MinStack()\nminStack.push(-2)\nminStack.push(0)\nminStack.push(-3)\nprint(minStack.getMin())  # return -3\nminStack.pop()\nprint(minStack.top())     # return 0\nprint(minStack.getMin())  # return -2']"
You are given an array of strings `tokens` that represents an arithmetic expression in Reverse Polish Notation. Evaluate the expression and return an integer that represents the value of the expression.,Evaluate Reverse Polish Notation,"Input: tokens = [""2"",""1"",""+"",""3"",""*""] Output: 9 Explanation: ((2 + 1) * 3) = 9","1 <= tokens.length <= 10^4; tokens[i] is either an operator: ""+"", ""-"", ""*"", or ""/"", or an integer in the range [-200, 200].",https://leetcode.com/problems/Evaluate-Reverse-Polish-Notation/,Evaluate Reverse Polish Notation,Stack,"['class Solution:\n    def evalRPN(self, tokens: list[str]) -> int:\n        stack = []\n\n        for token in tokens:\n            if token in ""+-*/"":\n                b, a = stack.pop(), stack.pop()\n                if token == \'+\':\n                    stack.append(a + b)\n                elif token == \'-\':\n                    stack.append(a - b)\n                elif token == \'*\':\n                    stack.append(a * b)\n                elif token == \'/\':\n                    # Use int() for truncating division towards zero\n                    stack.append(int(a / b))\n            else:\n                stack.append(int(token))\n\n        return stack[0]', '# Test the examples\n\nevalRPN = Solution().evalRPN\n\nexamples = [\n    [""2"", ""1"", ""+"", ""3"", ""*""],\n    [""4"", ""13"", ""5"", ""/"", ""+""],\n    [""10"", ""6"", ""9"", ""3"", ""+"", ""-11"", ""*"", ""/"", ""*"", ""17"", ""+"", ""5"", ""+""]\n]\n\nresults = [evalRPN(e) for e in examples]\nresults']"
What are the time and space complexities of the corrected implementation for a basic calculator?,Analyze calculator complexity,"Input: '1 + (2 - (3 + 4))', Output: Time Complexity: O(n), Space Complexity: O(n)","Input string length n, fully nested expressions",https://leetcode.com/problems/Basic-Calculator/,Basic Calculator,Stack,"['class Solution:\n    def calculate(self, s: str) -> int:\n        stack = []  # Stack to keep track of numbers and the result of parentheses evaluations\n        num = 0\n        sign = 1  # 1 for positive numbers, -1 for negative numbers\n        result = 0  # Current result\n\n        for char in s:\n            if char.isdigit():\n                num = num * 10 + int(char)\n            elif char in ""+-"":\n                result += sign * num\n                num = 0\n                sign = 1 if char == \'+\' else -1\n            elif char == \'(\':\n                # Push the current result and the sign onto the stack, then reset them\n                stack.append(result)\n                stack.append(sign)\n                sign = 1\n                result = 0\n            elif char == \')\':\n                result += sign * num\n                num = 0\n                result *= stack.pop()  # Last sign before \'(\'\n                result += stack.pop()  # Result calculated before \'(\'\n\n        result += sign * num  # Add the last number\n        return result', 'calculate = Solution().calculate\n\ntest_cases = [""1 + 1"", "" 2-1 + 2 "", ""(1+(4+5+2)-3)+(6+8)""]\nresults_readable = [calculate(s) for s in test_cases]\nresults_readable']"
How can we determine if a linked list has a cycle using Floyd's Tortoise and Hare algorithm with constant memory?,Detect cycle in linked list,"Input: head = [3,2,0,-4] (cycle at node with value 2); Output: True. Input: head = [1,2]; Output: False.",Use O(1) memory.,https://leetcode.com/problems/Linked-List-Cycle/,Linked List Cycle,Linked List,"['from typing import Optional\n\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val: int):\n        self.val = val\n        self.next: ListNode | None = None\n\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        if not head or not head.next:\n            return False\n\n        slow = head\n        fast = head.next\n\n        while slow != fast:\n            if not fast or not fast.next:\n                return False\n            slow = slow.next\n            fast = fast.next.next\n\n        return True', ""hasCycle = Solution().hasCycle\n\n# Helper function to create a linked list from a list of values and a position where the tail connects to.\n# If pos is -1, the list does not have a cycle.\n\n\ndef createLinkedListAndTest(vals, pos):\n    if not vals:\n        return hasCycle(None)  # Test an empty list\n\n    head = ListNode(vals[0])\n    current = head\n    # Node to connect the tail to if there's a cycle\n    cycle_node = None if pos < 0 else head\n\n    for i in range(1, len(vals)):\n        current.next = ListNode(vals[i])\n        current = current.next\n        if i == pos:\n            cycle_node = current\n\n    if pos >= 0:  # Create a cycle\n        current.next = cycle_node\n\n    return hasCycle(head)\n\n\n# Test cases\ntest_cases = [\n    ([3, 2, 0, -4], 1),  # Example 1, should return True\n    ([1, 2], 0),         # Example 2, should return True\n    ([1], -1),           # Example 3, should return False\n    ([], -1),            # Empty list, should return False\n    # List with 5 elements, cycle starts at index 2, should return True\n    ([1, 2, 3, 4, 5], 2)\n]\n\n# Execute test cases\ntest_results = [createLinkedListAndTest(tc[0], tc[1]) for tc in test_cases]\ntest_results""]"
"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",Add two numbers represented as lists,"Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8]","The number of nodes in each linked list is in the range [1, 100]. 0 <= Node.val <= 9. It is guaranteed that the list represents a number that does not have leading zeros.",https://leetcode.com/problems/Add-Two-Numbers/,Add Two Numbers,Linked List,"['from typing import Optional\nfrom __future__ import annotations\n\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val: int):\n        self.val = val\n        self.next: ListNode | None = None\n\n    @staticmethod\n    def from_list(l: list[int]) -> ListNode | None:\n        if not l:  # Check if the list is empty\n            return None  # Return None if the list is empty\n        head = ListNode(l[0])\n        current = head\n        for i in l[1:]:\n            current.next = ListNode(i)\n            current = current.next\n        return head\n\n    def to_list(self) -> list[int]:\n        l = [self.val]\n        current = self\n        while current.next:\n            current = current.next\n            l.append(current.val)\n        return l\n\n    def print(self) -> None:\n        print(self.to_list())', 'class Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        # create a dummy head to simplify the code\n        dummy_head = ListNode(0)\n        current = dummy_head\n        carry = 0\n        \n        p, q = l1, l2\n        \n        while p or q:\n            # traverse both lists at the same time, if one list is shorter than the other, use 0\n            x = p.val if p else 0\n            y = q.val if q else 0\n            \n            # calculate the sum of the two digits and the carry\n            sum = carry + x + y\n            \n            # calculate the carry for the next iteration\n            carry = sum // 10\n            \n            # add a new node with the sum value\n            current.next = ListNode(sum % 10)\n            \n            # move to the next node in the result list\n            current = current.next\n            \n            # move to the next node in both lists\n            if p:\n                p = p.next\n            if q:\n                q = q.next\n        \n        # if there is a carry left, add a new node with the carry value\n        if carry > 0:\n            current.next = ListNode(carry)\n        \n        return dummy_head.next', '# Example usage\n\nadd_two_numbers = Solution().addTwoNumbers\n\nl1 = ListNode.from_list([2, 4, 3])\nl2 = ListNode.from_list([5, 6, 4])\nresult = add_two_numbers(l1, l2)\nresult.print()  # Expected output: 7 -> 0 -> 8\n\nl1 = ListNode.from_list([0])\nl2 = ListNode.from_list([0])\nresult = add_two_numbers(l1, l2)\nresult.print()  # Expected output: 0\n\nl1 = ListNode.from_list([9, 9, 9, 9, 9, 9, 9])\nl2 = ListNode.from_list([9, 9, 9, 9])\nresult = add_two_numbers(l1, l2)\nresult.print()  # Expected output: 8 -> 9 -> 9 -> 9 -> 0 -> 0 -> 0 -> 1']"
You are given the heads of two sorted linked lists `list1` and `list2`. Merge the two lists into one sorted list by splicing together the nodes of the first two lists. Return the head of the merged linked list.,Merge two sorted linked lists,"Input: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4]; Input: list1 = [], list2 = [] Output: []; Input: list1 = [], list2 = [0] Output: [0]","The number of nodes in both lists is in the range [0, 50]. -100 <= Node.val <= 100. Both list1 and list2 are sorted in non-decreasing order.",https://leetcode.com/problems/Merge-Two-Sorted-Lists/,Merge Two Sorted Lists,Linked List,"['from typing import Optional\nfrom __future__ import annotations\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val: int = 0, next: Optional[ListNode] = None):\n        self.val = val\n        self.next = next\n        \n    @staticmethod\n    def from_list(l: list[int]) -> ListNode | None:\n        if not l:  # Check if the list is empty\n            return None  # Return None if the list is empty\n        head = ListNode(l[0])\n        current = head\n        for i in l[1:]:\n            current.next = ListNode(i)\n            current = current.next\n        return head\n\n    def to_list(self) -> list[int]:\n        l = [self.val]\n        current = self\n        while current.next:\n            current = current.next\n            l.append(current.val)\n        return l\n\n    def print(self) -> None:\n        print(self.to_list())', 'class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        # create a dummy node to hold the result\n        dummy = ListNode(-1)\n        prev = dummy\n\n        # while both lists are not empty\n        while list1 and list2:\n            if list1.val <= list2.val:\n                prev.next = list1\n                list1 = list1.next\n            else:\n                prev.next = list2\n                list2 = list2.next\n            prev = prev.next\n\n        # if one of the lists is empty, append the other\n        prev.next = list1 if list1 is not None else list2\n\n        return dummy.next', 'solution = Solution()\n\nresults = []\n\ntest_cases = [\n    ([1, 2, 4], [1, 3, 4]),\n    ([], []),\n    ([], [0])\n]\n\nfor list1, list2 in test_cases:\n    l1 = ListNode.from_list(list1)\n    l2 = ListNode.from_list(list2)\n    merged_list_head = solution.mergeTwoLists(l1, l2)\n    if merged_list_head:  # added a simple case handle if None\n        results.append(merged_list_head.to_list())\n    else:\n        results.append([])\n\nresults']"
"Construct a deep copy of a linked list with random pointers, ensuring that the new nodes do not point to the original list.",Deep copy linked list,"Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]; Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]",0 <= n <= 1000; -10^4 <= Node.val <= 10^4; Node.random is null or points to a node in the list.,https://leetcode.com/problems/Copy-List-with-Random-Pointer/,Copy List with Random Pointer,Linked List,"['from __future__ import annotations\nfrom typing import Optional\n\n\n\n""""""\n# Definition for a Node.\n""""""\nclass Node:\n    def __init__(self, x: int, next: Node = None, random: Node = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\nclass Solution:\n    def copyRandomList(self, head: Optional[Node]) -> Optional[Node]:\n        if not head:\n            return None\n\n        # Step 1: Create a copy of each node and place it next to the original node\n        current = head\n        while current:\n            new_node = Node(current.val, current.next, current.random)\n            current.next = new_node\n            current = new_node.next\n\n        # Step 2: Set the random pointers for the copied nodes\n        current = head\n        while current:\n            if current.random:\n                current.next.random = current.random.next\n            current = current.next.next\n\n        # Step 3: Restore the original list and extract the copied list\n        current = head\n        copy_head = head.next\n        while current:\n            temp = current.next\n            current.next = temp.next\n            if temp.next:\n                temp.next = temp.next.next\n            current = current.next\n\n        return copy_head', ""# Helper function to print the list to verify the solution\ndef printList(head):\n    result = []\n    while head:\n        random_val = head.random.val if head.random else 'null'\n        result.append([head.val, random_val])\n        head = head.next\n    return result"", '# Example 1\ncopyRandomList = Solution().copyRandomList\n\nnode1 = Node(7)\nnode2 = Node(13)\nnode3 = Node(11)\nnode4 = Node(10)\nnode5 = Node(1)\n\nnode1.next = node2\nnode2.next = node3\nnode3.next = node4\nnode4.next = node5\n\nnode2.random = node1\nnode3.random = node5\nnode4.random = node3\nnode5.random = node1\n\ncopied_head = copyRandomList(node1)\nprintList(copied_head)']"
"Given the head of a singly linked list and two integers `left` and `right`, reverse the nodes of the list from position `left` to position `right`, and return the reversed list.",Reverse linked list segment,"Input: head = [1,2,3,4,5], left = 2, right = 4; Output: [1,4,3,2,5]","1 <= n <= 500, -500 <= Node.val <= 500, 1 <= left <= right <= n",https://leetcode.com/problems/Reverse-Linked-List/,Reverse Linked List,Linked List,"['from __future__ import annotations\nfrom typing import Optional', '# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val: int = 0, next: Optional[ListNode] = None):\n        self.val = val\n        self.next = next\n        \n    @staticmethod\n    def from_list(l: list[int]) -> ListNode | None:\n        if not l:  # Check if the list is empty\n            return None  # Return None if the list is empty\n        head = ListNode(l[0])\n        current = head\n        for i in l[1:]:\n            current.next = ListNode(i)\n            current = current.next\n        return head\n\n    def to_list(self) -> list[int]:\n        l = [self.val]\n        current = self\n        while current.next:\n            current = current.next\n            l.append(current.val)\n        return l\n\n    def print(self) -> None:\n        print(self.to_list())', 'class Solution:\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\n        if not head or left == right:\n            return head\n\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n\n        # Move `prev` to the element just before the start of the sub-list to be reversed\n        for _ in range(left - 1):\n            prev = prev.next\n\n        # Start reversing the sub-list\n        reverse = None\n        current = prev.next\n        for _ in range(right - left + 1):\n            next_temp = current.next\n            current.next = reverse\n            reverse = current\n            current = next_temp\n\n        # Connect the start of the sub-list to the part after the reversed sub-list\n        prev.next.next = current\n        # Connect `prev` to the start of the reversed sub-list\n        prev.next = reverse\n\n        return dummy.next\n    ', 'solution = Solution()\n\n# Example 1\nhead = ListNode.from_list([1, 2, 3, 4, 5])\nresult_head: ListNode = solution.reverseBetween(head, 2, 4)\nresult_head.print()  # Expected output: [1, 4, 3, 2, 5]\n\n# Example 2\nhead = ListNode.from_list([5])\nresult_head = solution.reverseBetween(head, 1, 1)\nresult_head.print()  # Expected output: [5]']"
"Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. If the number of nodes is not a multiple of k, the left-out nodes should remain as they are. You may not alter the values in the list's nodes, only nodes themselves may be changed.",Reverse nodes in k-group,"Input: head = [1,2,3,4,5], k = 2; Output: [2,1,4,3,5]. Input: head = [1,2,3,4,5], k = 3; Output: [3,2,1,4,5].",1 <= k <= n <= 5000; 0 <= Node.val <= 1000.,https://leetcode.com/problems/Reverse-List-in-K-Group/,Reverse List in K Group,Linked List,"['from __future__ import annotations\nfrom typing import Optional', '# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val: int = 0, next: Optional[ListNode] = None):\n        self.val = val\n        self.next = next\n\n    @staticmethod\n    def from_list(l: list[int]) -> ListNode | None:\n        if not l:  # Check if the list is empty\n            return None  # Return None if the list is empty\n        head = ListNode(l[0])\n        current = head\n        for i in l[1:]:\n            current.next = ListNode(i)\n            current = current.next\n        return head\n\n    def to_list(self) -> list[int]:\n        l = [self.val]\n        current = self\n        while current.next:\n            current = current.next\n            l.append(current.val)\n        return l\n\n    def print(self) -> None:\n        print(self.to_list())', 'class Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head is None or k == 1:\n            return head\n\n        # Dummy node to act as the starting point\n        dummy = ListNode(-1)\n        dummy.next = head\n\n        # Initialize pointers\n        prev = dummy\n        curr = dummy\n        next = dummy\n\n        # Count the number of nodes in the list\n        count = 0\n        while curr.next is not None:\n            curr = curr.next\n            count += 1\n\n        # Traverse the list and reverse every k nodes\n        while count >= k:\n            curr = prev.next  # The current node at the start of the k group\n            next = curr.next  # The next node to be processed\n            for i in range(1, k):  # Note: we already have the first node, so start from 1\n                curr.next = next.next\n                next.next = prev.next\n                prev.next = next\n                next = curr.next\n            prev = curr\n            count -= k\n\n        return dummy.next', '# Test cases\nsolution = Solution()\n\ntest_cases = [\n    ([1, 2, 3, 4, 5], 2),  # Example 1\n    ([1, 2, 3, 4, 5], 3),  # Example 2\n    ([1, 2, 3, 4, 5, 6], 3),\n    ([], 1),\n    ([1], 1)\n]\n\nresults = []\n\nfor inputs, k in test_cases:\n    head = ListNode.from_list(inputs)\n    result_head = solution.reverseKGroup(head, k)\n    result_list = result_head.to_list() if result_head else []\n    results.append((inputs, k, result_list))\n\nresults']"
"Given the head of a linked list, remove the nth node from the end of the list and return its head.",Remove Nth Node from List,"Input: head = [1,2,3,4,5], n = 2; Output: [1,2,3,5]",1 <= sz <= 30; 0 <= Node.val <= 100; 1 <= n <= sz,https://leetcode.com/problems/Remove-Nth-Node-from-End-of-List/,Remove Nth Node from End of List,Linked List,"['from __future__ import annotations\nfrom typing import Optional', '# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val: int = 0, next: Optional[ListNode] = None):\n        self.val = val\n        self.next = next\n\n    @staticmethod\n    def from_list(l: list[int]) -> ListNode | None:\n        if not l:  # Check if the list is empty\n            return None  # Return None if the list is empty\n        head = ListNode(l[0])\n        current = head\n        for i in l[1:]:\n            current.next = ListNode(i)\n            current = current.next\n        return head\n\n    def to_list(self) -> list[int]:\n        l = [self.val]\n        current = self\n        while current.next:\n            current = current.next\n            l.append(current.val)\n        return l\n\n    def print(self) -> None:\n        print(self.to_list())', 'class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        dummy = ListNode(0)\n        dummy.next = head\n        fast = slow = dummy\n\n        # advance fast pointer so that the gap between fast and slow is n nodes apart\n        for _ in range(n + 1):\n            fast = fast.next\n\n        # move fast to the end, maintaining the gap\n        while fast:\n            fast = fast.next\n            slow = slow.next\n\n        # remove the nth node from the end\n        slow.next = slow.next.next\n\n        return dummy.next', '# Example usage\ns = Solution()\n\nhead = ListNode.from_list([1, 2, 3, 4, 5])\nn = 2\nnew_head = s.removeNthFromEnd(head, n)\nprint(new_head.to_list())']"
"Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.",Remove duplicates from list,"Input: head = [1,2,3,3,4,4,5] Output: [1,2,5]; Input: head = [1,1,1,2,3] Output: [2,3]","The number of nodes in the list is in the range [0, 300]. -100 <= Node.val <= 100. The list is guaranteed to be sorted in ascending order.",https://leetcode.com/problems/Remove-Duplicates-from-Sorted-List-II/,Remove Duplicates from Sorted List II,Linked List,"['from __future__ import annotations\nfrom typing import Optional', '# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val: int = 0, next: Optional[ListNode] = None):\n        self.val = val\n        self.next = next\n\n    @staticmethod\n    def from_list(l: list[int]) -> ListNode | None:\n        if not l:  # Check if the list is empty\n            return None  # Return None if the list is empty\n        head = ListNode(l[0])\n        current = head\n        for i in l[1:]:\n            current.next = ListNode(i)\n            current = current.next\n        return head\n\n    def to_list(self) -> list[int]:\n        l = [self.val]\n        current = self\n        while current.next:\n            current = current.next\n            l.append(current.val)\n        return l\n\n    def print(self) -> None:\n        print(self.to_list())', ""class Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode(-1, head)\n\n        # `prev` is a lagging pointer to easily remove nodes with the same value\n        prev = dummy\n\n        while head:\n            # if we find a sequence of nodes with the same value\n            if head.next and head.val == head.next.val:\n                # skip the nodes with the same value\n                while head.next and head.val == head.next.val:\n                    head = head.next\n                # remove the nodes with the same value bt linking 'prev.next' to the node\n                # right after the last node with the same value\n                if prev:  # Ensure prev is not None\n                    prev.next = head.next\n            else:\n                # no duplicates found, move 'prev' to the next node\n                if prev:  # Ensure prev is not None\n                    prev = prev.next\n\n            # move 'head' to the next node\n            head = head.next\n\n        # return the modified list without the dummy node\n        return dummy.next"", 's = Solution()\n\nhead = ListNode.from_list([1, 2, 3, 3, 4, 4, 5])\nresult = s.deleteDuplicates(head)\nif result:\n    result.print()\n\nhead = ListNode.from_list([1, 1, 1, 2, 3])\nresult = s.deleteDuplicates(head)\nif result:\n    result.print()']"
How to rotate a linked list to the right by k places?,Rotate linked list right,"Input: head = [1,2,3,4,5], k = 2; Output: [4,5,1,2,3]","The list can be empty, k can be 0 or greater.",https://leetcode.com/problems/Rotate-List/,Rotate List,Linked List,"['from __future__ import annotations\nfrom typing import Optional', '# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val: int = 0, next: Optional[ListNode] = None):\n        self.val = val\n        self.next = next\n\n    @staticmethod\n    def from_list(l: list[int]) -> ListNode | None:\n        if not l:  # Check if the list is empty\n            return None  # Return None if the list is empty\n        head = ListNode(l[0])\n        current = head\n        for i in l[1:]:\n            current.next = ListNode(i)\n            current = current.next\n        return head\n\n    def to_list(self) -> list[int]:\n        l = [self.val]\n        current = self\n        while current.next:\n            current = current.next\n            l.append(current.val)\n        return l\n\n    def print(self) -> None:\n        print(self.to_list())', 'class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        # handle edge cases\n        if not head or k == 0:\n            return head\n\n        # step 1: find the length of the list\n        length = 1\n        current = head\n        while current.next:\n            current = current.next\n            length += 1\n\n        # step 2: make the list circular\n        current.next = head\n\n        # step 3: find the point of rotation\n        k = k % length\n        steps_to_new_head = length - k\n        while steps_to_new_head > 0:\n            if current.next:\n                current = current.next\n                steps_to_new_head -= 1\n\n        # step 4: break the circle and return the new head\n        new_head = current.next\n        current.next = None\n\n        return new_head', 's = Solution()\n\n# Test case 1\nhead = ListNode.from_list([1, 2, 3, 4, 5])\nrotated_head = s.rotateRight(head, 2)\nif rotated_head:\n    rotated_head.print()  # Expected: 4 -> 5 -> 1 -> 2 -> 3\n\n# Test case 2\nhead = ListNode.from_list([0, 1, 2])\nrotated_head = s.rotateRight(head, 4)\nif rotated_head:\n    rotated_head.print()  # Expected: 2 -> 0 -> 1']"
What are the time and space complexities of the partitioning algorithm for a linked list?,Analyze partitioning algorithm complexity,"Input: linked list [3, 5, 8, 5, 10, 2, 1], x = 5; Output: modified linked list [3, 2, 1, 5, 5, 8, 10]",The algorithm must operate in O(n) time and O(1) space.,https://leetcode.com/problems/Partition-List/,Partition List,Linked List,"['from __future__ import annotations\nfrom typing import Optional', '# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val: int = 0, next: Optional[ListNode] = None):\n        self.val = val\n        self.next = next\n\n    @staticmethod\n    def from_list(l: list[int]) -> ListNode | None:\n        if not l:  # Check if the list is empty\n            return None  # Return None if the list is empty\n        head = ListNode(l[0])\n        current = head\n        for i in l[1:]:\n            current.next = ListNode(i)\n            current = current.next\n        return head\n\n    def to_list(self) -> list[int]:\n        l = [self.val]\n        current = self\n        while current.next:\n            current = current.next\n            l.append(current.val)\n        return l\n\n    def print(self) -> None:\n        print(self.to_list())', ""class Solution:\n    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:\n        less_head = ListNode(0)  # Dummy head for the 'less' list\n        greater_head = ListNode(0)  # Dummy head for the 'greater' list\n        less = less_head  # Pointer for the 'less' list\n        greater = greater_head  # Pointer for the 'greater' list\n\n        while head:\n            if head.val < x:\n                less.next = head\n                less = less.next\n            else:\n                greater.next = head\n                greater = greater.next\n            head = head.next\n\n        greater.next = None  # Important to avoid cycle in linked list\n        less.next = greater_head.next  # Connect 'less' list with 'greater' list\n\n        return less_head.next  # Return the next of dummy head as it is the real head"", '# Test cases\n\ns = Solution()\n\ntest_cases = [([1, 4, 3, 2, 5, 2], 3), ([2, 1], 2)]\nresults = []\n\nfor arr, x in test_cases:\n    head = ListNode.from_list(arr)\n    partitioned_head = s.partition(head, x)\n    result = partitioned_head.to_list()\n    results.append(result)\n\nresults']"
"Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class with methods to get and put key-value pairs, ensuring O(1) average time complexity.",Implement LRU Cache,"Input: [""LRUCache"", ""put"", ""put"", ""get"", ""put"", ""get"", ""put"", ""get"", ""get"", ""get""] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]; Output: [null, null, null, 1, null, -1, null, -1, 3, 4]",1 <= capacity <= 3000; 0 <= key <= 10^4; 0 <= value <= 10^5; At most 2 * 10^5 calls will be made to get and put.,https://leetcode.com/problems/LRU-Cache/,LRU Cache,Linked List,"[""from collections import OrderedDict\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.order = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            # move the key to the end to indicate it's the most recently used\n            self.order.move_to_end(key)\n            return self.cache[key]\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache[key] = value\n            self.order.move_to_end(key)\n        else:\n            self.cache[key] = value\n            self.order[key] = None\n        if len(self.cache) > self.capacity:\n            oldest_key = next(iter(self.order))\n            del self.cache[oldest_key]\n            del self.order[oldest_key]"", '# Example Usage\nlRUCache = LRUCache(2)\noperations = [""put"", ""put"", ""get"", ""put"", ""get"", ""put"", ""get"", ""get"", ""get""]\nvalues = [[1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\noutput = [None]\n\nfor op, val in zip(operations, values):\n    if op == ""put"":\n        lRUCache.put(val[0], val[1])\n        output.append(None)\n    elif op == ""get"":\n        output.append(lRUCache.get(val[0]))\n\noutput']"
"Given the root of a binary tree, return its maximum depth, defined as the number of nodes along the longest path from the root node to the farthest leaf node.",Maximum depth of binary tree,"Input: root = [3,9,20,null,null,15,7] Output: 3; Input: root = [1,null,2] Output: 2","The number of nodes in the tree is in the range [0, 10^4]. -100 <= Node.val <= 100",https://leetcode.com/problems/Maximum-Depth-of-Binary-Tree/,Maximum Depth of Binary Tree,Binary Tree - General,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', '# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[TreeNode]:\n        """"""\n        Constructs a binary tree from a list of values using level-order traversal (BFS).\n\n        Parameters:\n        - values (list): The list of values to construct the binary tree from.\n\n        Returns:\n        TreeNode: The root of the constructed binary tree.\n        """"""\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self):\n        """"""\n        Prints the level order traversal of the tree (BFS).\n\n        Returns:\n        list: A list of lists, where each sublist contains the values of the tree nodes\n              at that depth.\n        """"""\n        queue = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            if current_node:\n                current_level.append(current_node.val)\n                queue.append((current_node.left, node_level + 1))\n                queue.append((current_node.right, node_level + 1))\n            else:\n                current_level.append(""None"")\n\n        if current_level:\n            result.append(current_level)\n        \n        # Remove trailing ""None"" values\n        result = [level for level in result if any(elem != ""None"" for elem in level)]\n\n        return result', 'class Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        """"""\n        Calculates the maximum depth of a binary tree (DFS).\n\n        Parameters:\n        - root (TreeNode): The root of the binary tree.\n\n        Returns:\n        int: The maximum depth of the tree.\n        """"""\n        if not root:\n            return 0\n\n        else:\n            left_depth = self.maxDepth(root.left)\n            right_depth = self.maxDepth(root.right)\n            return max(left_depth, right_depth) + 1', 's = Solution()\n\nvalues = [3, 9, 20, None, None, 15, 7]\nroot = TreeNode.from_list(values)\nprint(""Level Order:"", root.print_level_order())\nprint(""Max Depth:"", s.maxDepth(root))']"
"Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.",Check if two trees same,"Input: p = [1,2,3], q = [1,2,3] Output: true; Input: p = [1,2], q = [1,null,2] Output: false; Input: p = [1,2,1], q = [1,1,2] Output: false","The number of nodes in both trees is in the range `[0, 100]`. -10^4 <= Node.val <= 10^4",https://leetcode.com/problems/Same-Tree/,Same Tree,Binary Tree - General,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', '# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[TreeNode]:\n        """"""\n        Constructs a binary tree from a list of values using level-order traversal (BFS).\n\n        Parameters:\n        - values (list): The list of values to construct the binary tree from.\n\n        Returns:\n        TreeNode: The root of the constructed binary tree.\n        """"""\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self):\n        """"""\n        Prints the level order traversal of the tree (BFS).\n\n        Returns:\n        list: A list of lists, where each sublist contains the values of the tree nodes\n              at that depth.\n        """"""\n        queue = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            if current_node:\n                current_level.append(current_node.val)\n                queue.append((current_node.left, node_level + 1))\n                queue.append((current_node.right, node_level + 1))\n            else:\n                current_level.append(""None"")\n\n        if current_level:\n            result.append(current_level)\n        \n        # Remove trailing ""None"" values\n        result = [level for level in result if any(elem != ""None"" for elem in level)]\n\n        return result', 'class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        # if both trees are empty, then they are the same\n        if not p and not q:\n            return True\n\n        # if one of the trees is empty, then they are not the same\n        if not p or not q:\n            return False\n\n        # if the values of the nodes are different, then the trees are not the same\n        if p.val != q.val:\n            return False\n\n        # recursively check the left and right subtrees\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)', 's = Solution()\n\n# Example 1\np1 = [1, 2, 3]\nq1 = [1, 2, 3]\np1_tree = TreeNode.from_list(p1)\nq1_tree = TreeNode.from_list(q1)\n\n# Example 2\np2 = [1, 2]\nq2 = [1, None, 2]\np2_tree = TreeNode.from_list(p2)\nq2_tree = TreeNode.from_list(q2)\n\n# Example 3\np3 = [1, 2, 1]\nq3 = [1, 1, 2]\np3_tree = TreeNode.from_list(p3)\nq3_tree = TreeNode.from_list(q3)\n\nexample1_result = s.isSameTree(p1_tree, q1_tree)\nexample2_result = s.isSameTree(p2_tree, q2_tree)\nexample3_result = s.isSameTree(p3_tree, q3_tree)\n\n(example1_result, example2_result, example3_result)']"
"Given the root of a binary tree, invert the tree, and return its root.",Invert Binary Tree,"Input: root = [4,2,7,1,3,6,9] Output: [4,7,2,9,6,3,1]; Input: root = [2,1,3] Output: [2,3,1]; Input: root = [] Output: []","The number of nodes in the tree is in the range [0, 100]. -100 <= Node.val <= 100",https://leetcode.com/problems/Invert-Binary-Tree/,Invert Binary Tree,Binary Tree - General,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', '# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[TreeNode]:\n        """"""\n        Constructs a binary tree from a list of values using level-order traversal (BFS).\n\n        Parameters:\n        - values (list): The list of values to construct the binary tree from.\n\n        Returns:\n        TreeNode: The root of the constructed binary tree.\n        """"""\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self):\n        """"""\n        Prints the level order traversal of the tree (BFS).\n\n        Returns:\n        list: A list of lists, where each sublist contains the values of the tree nodes\n              at that depth.\n        """"""\n        queue = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            if current_node:\n                current_level.append(current_node.val)\n                queue.append((current_node.left, node_level + 1))\n                queue.append((current_node.right, node_level + 1))\n            else:\n                current_level.append(""None"")\n\n        if current_level:\n            result.append(current_level)\n        \n        # Remove trailing ""None"" values\n        result = [level for level in result if any(elem != ""None"" for elem in level)]\n\n        return result', 'class Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n                return None\n        \n        # Swap the left and right children\n        root.left, root.right = root.right, root.left\n    \n        # Recursively invert the left and right subtrees\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n    \n        return root', 's = Solution()\n\n# Test cases\ntest_cases = [\n    [4, 2, 7, 1, 3, 6, 9],\n    [2, 1, 3],\n    [],\n    [1],\n    [1, 2]\n]\n\n# Execute test cases\nresults = []\nfor case in test_cases:\n    root = TreeNode.from_list(case)\n    inverted_root = s.invertTree(root)\n    results.append((inverted_root).print_level_order() if inverted_root else [])\n\nresults']"
"Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",Check symmetric binary tree,"Input: root = [1,2,2,3,4,4,3] Output: true; Input: root = [1,2,2,null,3,null,3] Output: false","The number of nodes in the tree is in the range [1, 1000]. -100 <= Node.val <= 100",https://leetcode.com/problems/Symmetric-Tree/,Symmetric Tree,Binary Tree - General,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', '# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[TreeNode]:\n        """"""\n        Constructs a binary tree from a list of values using level-order traversal (BFS).\n\n        Parameters:\n        - values (list): The list of values to construct the binary tree from.\n\n        Returns:\n        TreeNode: The root of the constructed binary tree.\n        """"""\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self):\n        """"""\n        Prints the level order traversal of the tree (BFS).\n\n        Returns:\n        list: A list of lists, where each sublist contains the values of the tree nodes\n              at that depth.\n        """"""\n        queue = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            if current_node:\n                current_level.append(current_node.val)\n                queue.append((current_node.left, node_level + 1))\n                queue.append((current_node.right, node_level + 1))\n            else:\n                current_level.append(""None"")\n\n        if current_level:\n            result.append(current_level)\n        \n        # Remove trailing ""None"" values\n        result = [level for level in result if any(elem != ""None"" for elem in level)]\n\n        return result', 'class Solution:\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\n        def isMirror(t1: Optional[TreeNode], t2: Optional[TreeNode]) -> bool:\n            if not t1 and not t2:\n                return True\n            if not t1 or not t2:\n                return False\n            return (t1.val == t2.val) and isMirror(t1.left, t2.right) and isMirror(t1.right, t2.left)\n\n        return isMirror(root, root)\n\n    def isSymmetricIterative(self, root: Optional[TreeNode]) -> bool:\n        if not root:\n            return True\n\n        queue = deque([(root.left, root.right)])\n        while queue:\n            t1, t2 = queue.popleft()\n            if not t1 and not t2:\n                continue\n            if not t1 or not t2:\n                return False\n            if t1.val != t2.val:\n                return False\n            queue.append((t1.left, t2.right))\n            queue.append((t1.right, t2.left))\n\n        return True', 's = Solution()\n\n# Test Cases\nroot = TreeNode.from_list([1, 2, 2, 3, 4, 4, 3])\nassert s.isSymmetric(root) == True\nassert s.isSymmetricIterative(root) == True\n\nroot = TreeNode.from_list([1, 2, 2, None, 3, None, 3])\nassert s.isSymmetric(root) == False\nassert s.isSymmetricIterative(root) == False']"
"Given two integer arrays `preorder` and `inorder`, construct and return the binary tree represented by these traversals.",Construct binary tree from traversals,"Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] Output: [3,9,20,null,null,15,7]","1 <= preorder.length <= 3000; inorder.length == preorder.length; -3000 <= preorder[i], inorder[i] <= 3000; unique values in both arrays; preorder is the preorder traversal; inorder is the inorder traversal.",https://leetcode.com/problems/Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/,Construct Binary Tree from Preorder and Inorder Traversal,Binary Tree - General,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', '# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[TreeNode]:\n        """"""\n        Constructs a binary tree from a list of values using level-order traversal (BFS).\n\n        Parameters:\n        - values (list): The list of values to construct the binary tree from.\n\n        Returns:\n        TreeNode: The root of the constructed binary tree.\n        """"""\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self):\n        """"""\n        Prints the level order traversal of the tree (BFS).\n\n        Returns:\n        list: A list of lists, where each sublist contains the values of the tree nodes\n              at that depth.\n        """"""\n        queue = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            if current_node:\n                current_level.append(current_node.val)\n                queue.append((current_node.left, node_level + 1))\n                queue.append((current_node.right, node_level + 1))\n            else:\n                current_level.append(""None"")\n\n        if current_level:\n            result.append(current_level)\n        \n        # Remove trailing ""None"" values\n        result = [level for level in result if any(elem != ""None"" for elem in level)]\n\n        return result', 'class Solution:\n    # divide and conquer - find root in preorder list, then split inorder list into left and right subtrees\n    def buildTree(self, preorder: list[int], inorder: list[int]) -> Optional[TreeNode]:\n        if not preorder or not inorder:\n            return None\n\n        # root is the first element in the preorder list\n        root_val = preorder.pop(0)\n        root = TreeNode(val=root_val)\n\n        # find the index of the root value in the inorder list to split into left and right subtrees\n        root_index = inorder.index(root_val)\n\n        # recursively build the left and right subtrees\n        root.left = self.buildTree(preorder, inorder[:root_index])\n        root.right = self.buildTree(preorder, inorder[root_index + 1:])\n\n        return root', '# Test case\n\ns = Solution()\n\npreorder = [3,9,20,15,7]\ninorder = [9,3,15,20,7]\ntree = s.buildTree(preorder, inorder)\n\ntree.print_level_order()']"
How to reconstruct a binary tree using inorder and postorder traversal arrays?,Reconstruct binary tree from traversals,"Inorder: [9,3,15,20,7], Postorder: [9,15,7,20,3] → Tree: 3, left: 9, right: 20 (left: 15, right: 7)",Input arrays are valid and represent a binary tree.,https://leetcode.com/problems/Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/,Construct Binary Tree from Inorder and Postorder Traversal,Binary Tree - General,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', '# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[TreeNode]:\n        """"""\n        Constructs a binary tree from a list of values using level-order traversal (BFS).\n\n        Parameters:\n        - values (list): The list of values to construct the binary tree from.\n\n        Returns:\n        TreeNode: The root of the constructed binary tree.\n        """"""\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self):\n        """"""\n        Prints the level order traversal of the tree (BFS).\n\n        Returns:\n        list: A list of lists, where each sublist contains the values of the tree nodes\n              at that depth.\n        """"""\n        queue = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            if current_node:\n                current_level.append(current_node.val)\n                queue.append((current_node.left, node_level + 1))\n                queue.append((current_node.right, node_level + 1))\n            else:\n                current_level.append(""None"")\n\n        if current_level:\n            result.append(current_level)\n        \n        # Remove trailing ""None"" values\n        result = [level for level in result if any(elem != ""None"" for elem in level)]\n\n        return result', 'class Solution:\n    # divide and conquer - find root in postorder, then find left and right subtrees in inorder\n    def buildTree(self, inorder: list[int], postorder: list[int]) -> Optional[TreeNode]:\n        if not inorder or not postorder:\n            return None\n\n        # the last element in postorder is the root\n        root_val = postorder.pop()\n        root = TreeNode(root_val)\n\n        # find the index of the root in inorder\n        root_index = inorder.index(root_val)\n\n        # find the right subtree in inorder\n        root.right = self.buildTree(inorder[root_index + 1:], postorder)\n        root.left = self.buildTree(inorder[:root_index], postorder)\n\n        return root', '# Test case\n\ns = Solution()\n\nroot = s.buildTree([9, 3, 15, 20, 7], [9, 15, 7, 20, 3])\nroot.print_level_order()']"
"Given a binary tree, populate each next pointer to point to its next right node, setting it to NULL if there is no next right node.",Populate next right pointers,"Input: root = [1,2,3,4,5,null,7]; Output: [1,#,2,3,#,4,5,7,#]. Input: root = []; Output: [].","The number of nodes in the tree is in the range [0, 6000]. -100 <= Node.val <= 100.",https://leetcode.com/problems/Populating-Next-Right-Pointers-in-Each-Node-II/,Populating Next Right Pointers in Each Node II,Binary Tree - General,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', '# Definition for a binary tree node.\nclass Node:\n    def __init__(self, val=0, left=None, right=None, next=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[Node]:\n        """"""\n        Constructs a binary tree from a list of values using level-order traversal (BFS).\n\n        Parameters:\n        - values (list): The list of values to construct the binary tree from.\n\n        Returns:\n        TreeNode: The root of the constructed binary tree.\n        """"""\n        if not values:\n            return None\n\n        root = Node(val=values[0])\n        queue = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = Node(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = Node(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self):\n        """"""\n        Prints the level order traversal of the tree (BFS).\n\n        Returns:\n        list: A list of lists, where each sublist contains the values of the tree nodes\n              at that depth.\n        """"""\n        queue = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            if current_node:\n                current_level.append(current_node.val)\n                queue.append((current_node.left, node_level + 1))\n                queue.append((current_node.right, node_level + 1))\n            else:\n                current_level.append(""None"")\n\n        if current_level:\n            result.append(current_level)\n\n        # Remove trailing ""None"" values\n        result = [level for level in result if any(\n            elem != ""None"" for elem in level)]\n\n        return result\n\n    def print_tree_by_levels(self):\n        while self:\n            current = self\n\n            while current:\n                print(current.val, end="" -> "")\n                current = current.next\n\n            print(""#"")  # indicate the end of the current level\n            if self.left:\n                self = self.left\n            elif self.right:\n                self = self.right\n            else:\n                # If the current level is completely traversed and there\'s no left or right child,\n                # we need to find the next available node in the next level if it exists\n                next_level = self.next\n                while next_level and not (next_level.left or next_level.right):\n                    next_level = next_level.next\n                self = next_level.left if next_level and next_level.left else next_level.right if next_level else None', 'class Solution:\n    def connect(self, root: Node) -> Node:\n        if not root:\n            return None\n\n        # start with the root node; the head of the first level\n        level_start = root\n\n        # while there are nodes at the current level\n        while level_start:\n            current = level_start\n            # use a dummy node to establish the head of the next level\n            dummy = Node()\n            tail = dummy\n\n            # while there are nodes at the current level\n            while current:\n                # if the current node has a left child, append it to the tail\n                if current.left:\n                    tail.next = current.left\n                    tail = tail.next\n                # if the current node has a right child, append it to the tail\n                if current.right:\n                    tail.next = current.right\n                    tail = tail.next\n                current = current.next\n            # move to the next level and repeat\n            level_start = dummy.next\n\n        return root', '# Test\ns = Solution()\n\nroot = Node.from_list([1, 2, 3, 4, 5, None, 7])\nroot = s.connect(root)\n\nroot.print_tree_by_levels()']"
"Given the root of a binary tree, flatten the tree into a linked list where the right child points to the next node in pre-order traversal and the left child is always null.",Flatten binary tree to list,"Input: root = [1,2,5,3,4,null,6] Output: [1,null,2,null,3,null,4,null,5,null,6]","The number of nodes in the tree is in the range [0, 2000]. -100 <= Node.val <= 100",https://leetcode.com/problems/Flatten-Binary-Tree-to-Linked-List/,Flatten Binary Tree to Linked List,Binary Tree - General,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', '# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[TreeNode]:\n        """"""\n        Constructs a binary tree from a list of values using level-order traversal (BFS).\n\n        Parameters:\n        - values (list): The list of values to construct the binary tree from.\n\n        Returns:\n        TreeNode: The root of the constructed binary tree.\n        """"""\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self):\n        """"""\n        Prints the level order traversal of the tree (BFS).\n\n        Returns:\n        list: A list of lists, where each sublist contains the values of the tree nodes\n              at that depth.\n        """"""\n        queue = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            if current_node:\n                current_level.append(current_node.val)\n                queue.append((current_node.left, node_level + 1))\n                queue.append((current_node.right, node_level + 1))\n            else:\n                current_level.append(""None"")\n\n        if current_level:\n            result.append(current_level)\n        \n        # Remove trailing ""None"" values\n        result = [level for level in result if any(elem != ""None"" for elem in level)]\n\n        return result', 'class Solution:\n    def flatten(self, root: Optional[TreeNode]) -> None:\n        """"""\n        Do not return anything, modify root in-place instead.\n        """"""\n        current = root\n\n        while current:\n            if current.left:\n                # Find the rightmost node in the left subtree\n                rightmost = current.left\n                while rightmost.right:\n                    rightmost = rightmost.right\n\n                # Move the right subtree to the rightmost node\n                rightmost.right = current.right\n                current.right = current.left\n                current.left = None\n\n            # Move to the next node in the pre-order traversal\n            current = current.right', '# Test\n\ns = Solution()\n\nroot = TreeNode.from_list([1, 2, 5, 3, 4, None, 6])\ns.flatten(root)\nroot.print_level_order()']"
"Given the root of a binary tree and an integer targetSum, return true if there is a root-to-leaf path such that the sum of the values along the path equals targetSum.",Binary tree path sum check,"Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22; Output: true. Input: root = [1,2,3], targetSum = 5; Output: false. Input: root = [], targetSum = 0; Output: false.","The number of nodes in the tree is in the range [0, 5000]. -1000 <= Node.val <= 1000. -1000 <= targetSum <= 1000.",https://leetcode.com/problems/Path-Sum/,Path Sum,Binary Tree - General,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', '# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[TreeNode]:\n        """"""\n        Constructs a binary tree from a list of values using level-order traversal (BFS).\n\n        Parameters:\n        - values (list): The list of values to construct the binary tree from.\n\n        Returns:\n        TreeNode: The root of the constructed binary tree.\n        """"""\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self):\n        """"""\n        Prints the level order traversal of the tree (BFS).\n\n        Returns:\n        list: A list of lists, where each sublist contains the values of the tree nodes\n              at that depth.\n        """"""\n        queue = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            if current_node:\n                current_level.append(current_node.val)\n                queue.append((current_node.left, node_level + 1))\n                queue.append((current_node.right, node_level + 1))\n            else:\n                current_level.append(""None"")\n\n        if current_level:\n            result.append(current_level)\n        \n        # Remove trailing ""None"" values\n        result = [level for level in result if any(elem != ""None"" for elem in level)]\n\n        return result', 'class Solution:\n    def hasPathSum(self, root: Optional[TreeNode], target_sum: int) -> bool:\n        # Recursive DFS to check if a path exists from the root to a leaf node\n        def dfs(node: Optional[TreeNode], current_sum: int) -> bool:\n            if not node:\n                return False\n\n            current_sum += node.val\n\n            if not node.left and not node.right:\n                return current_sum == target_sum\n\n            return dfs(node.left, current_sum) or dfs(node.right, current_sum)\n\n        return dfs(root, 0) if root else False', '# Test Case\n\ns = Solution()\n\nroot = TreeNode.from_list([5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, 1])\ntarget = 22\nprint(s.hasPathSum(root, target)) # True\n\nroot = TreeNode.from_list([1, 2, 3])\ntarget = 5\nprint(s.hasPathSum(root, target)) # False\n\nroot = TreeNode.from_list([])\ntarget = 0\nprint(s.hasPathSum(root, target)) # False']"
"Given a binary tree with digits from 0 to 9, return the total sum of all root-to-leaf numbers represented by the paths.",Sum root to leaf numbers,"Input: root = [1,2,3] Output: 25; Input: root = [4,9,0,5,1] Output: 1026",1 <= number of nodes <= 1000; 0 <= Node.val <= 9; tree depth <= 10,https://leetcode.com/problems/Sum-Root-to-Leaf-Numbers/,Sum Root to Leaf Numbers,Binary Tree - General,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', '# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[TreeNode]:\n        """"""\n        Constructs a binary tree from a list of values using level-order traversal (BFS).\n\n        Parameters:\n        - values (list): The list of values to construct the binary tree from.\n\n        Returns:\n        TreeNode: The root of the constructed binary tree.\n        """"""\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self):\n        """"""\n        Prints the level order traversal of the tree (BFS).\n\n        Returns:\n        list: A list of lists, where each sublist contains the values of the tree nodes\n              at that depth.\n        """"""\n        queue = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            if current_node:\n                current_level.append(current_node.val)\n                queue.append((current_node.left, node_level + 1))\n                queue.append((current_node.right, node_level + 1))\n            else:\n                current_level.append(""None"")\n\n        if current_level:\n            result.append(current_level)\n        \n        # Remove trailing ""None"" values\n        result = [level for level in result if any(elem != ""None"" for elem in level)]\n\n        return result', ""class Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(node: TreeNode, current_sum: int) -> int:\n            if not node:\n                return 0\n\n            current_sum = current_sum * 10 + node.val\n\n            # Check if it's a leaf node\n            if not node.left and not node.right:\n                return current_sum\n\n            # Recursively call dfs on left and right children\n            return dfs(node.left, current_sum) + dfs(node.right, current_sum)\n\n        return dfs(root, 0)"", '# Test\n\nsolution = Solution()\n\nroot = TreeNode.from_list([1, 2, 3])\nprint(solution.sumNumbers(root))  # 25\n\nroot = TreeNode.from_list([4, 9, 0, 5, 1])\nprint(solution.sumNumbers(root))  # 1026']"
"Given the root of a binary tree, return the maximum path sum of any non-empty path.",Maximum path sum in tree,"Input: root = [1,2,3], Output: 6; Input: root = [-10,9,20,null,null,15,7], Output: 42","The number of nodes is in the range [1, 3 * 10^4]. Node values are between -1000 and 1000.",https://leetcode.com/problems/Binary-Tree-Maximum-Path-Sum/,Binary Tree Maximum Path Sum,Binary Tree - General,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', '# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[TreeNode]:\n        """"""\n        Constructs a binary tree from a list of values using level-order traversal (BFS).\n\n        Parameters:\n        - values (list): The list of values to construct the binary tree from.\n\n        Returns:\n        TreeNode: The root of the constructed binary tree.\n        """"""\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self):\n        """"""\n        Prints the level order traversal of the tree (BFS).\n\n        Returns:\n        list: A list of lists, where each sublist contains the values of the tree nodes\n              at that depth.\n        """"""\n        queue = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            if current_node:\n                current_level.append(current_node.val)\n                queue.append((current_node.left, node_level + 1))\n                queue.append((current_node.right, node_level + 1))\n            else:\n                current_level.append(""None"")\n\n        if current_level:\n            result.append(current_level)\n        \n        # Remove trailing ""None"" values\n        result = [level for level in result if any(elem != ""None"" for elem in level)]\n\n        return result', 'class Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        max_path = float(""-inf"")  # Initialize to negative infinity\n\n        def dfs(node: Optional[TreeNode]) -> int:\n            nonlocal max_path\n            if not node:\n                return 0\n\n            # Calculate the maximum sum of the left and right subtrees\n            left_sum = max(dfs(node.left), 0)  # Only add to path if it\'s positive\n            right_sum = max(dfs(node.right), 0)  # Only add to path if it\'s positive\n\n            # Update the maximum path sum that includes the current node and both subtrees\n            max_path = max(max_path, node.val + left_sum + right_sum)\n\n            # Return the maximum path sum that includes the current node and either subtree\n            return node.val + max(left_sum, right_sum)\n\n        dfs(root)\n        return max_path', '# Test\n\nsolution = Solution()\n\nroot = TreeNode.from_list([1, 2, 3])\nres = solution.maxPathSum(root)  # Expected: 6\nprint(res)\n\nroot = TreeNode.from_list([-10, 9, 20, None, None, 15, 7])\nres = solution.maxPathSum(root)  # Expected: 42\nprint(res)']"
Implement the BSTIterator class for in-order traversal of a binary search tree.,Binary Search Tree Iterator,"Input: [""BSTIterator"", ""next"", ""next"", ""hasNext"", ""next"", ""hasNext"", ""next"", ""hasNext"", ""next"", ""hasNext""] with [[7, 3, 15, null, null, 9, 20]]; Output: [null, 3, 7, true, 9, true, 15, true, 20, false]",1 <= number of nodes <= 100000; 0 <= Node.val <= 1000000; At most 100000 calls to hasNext and next.,https://leetcode.com/problems/Binary-Search-Tree-Iterator/,Binary Search Tree Iterator,Binary Tree - General,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', '# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(\n        self,\n        val: int = 0,\n        left: Optional[TreeNode] = None,\n        right: Optional[TreeNode] = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[TreeNode]:\n        """"""\n        Constructs a binary tree from a list of values using level-order traversal (BFS).\n\n        Parameters:\n        - values (list): The list of values to construct the binary tree from.\n\n        Returns:\n        TreeNode: The root of the constructed binary tree.\n        """"""\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self):\n        """"""\n        Prints the level order traversal of the tree (BFS).\n\n        Returns:\n        list: A list of lists, where each sublist contains the values of the tree nodes\n              at that depth.\n        """"""\n        queue = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            if current_node:\n                current_level.append(current_node.val)\n                queue.append((current_node.left, node_level + 1))\n                queue.append((current_node.right, node_level + 1))\n            else:\n                current_level.append(""None"")\n\n        if current_level:\n            result.append(current_level)\n\n        # Remove trailing ""None"" values\n        result = [level for level in result if any(elem != ""None"" for elem in level)]\n\n        return result', 'class BSTIterator:\n    def __init__(self, root: Optional[TreeNode]):\n        self.stack: list[TreeNode] = []\n        self._leftmost_inorder(root)\n\n    def _leftmost_inorder(self, node: Optional[TreeNode]):\n        # Push all nodes from root to the left-most node\n        while node:\n            self.stack.append(node)\n            node = node.left\n\n    def next(self) -> int:\n        """"""\n        @return the next smallest number\n        """"""\n        # Pop the top node from the stack, process it, and then push all its right node\'s left children\n        topmost_node = self.stack.pop()\n        self._leftmost_inorder(topmost_node.right)\n\n        return topmost_node.val\n\n    def hasNext(self) -> bool:\n        """"""\n        @return whether we have a next smallest number\n        """"""\n        return len(self.stack) > 0', '# Creating a BST from a list\ntree_list = [7, 3, 15, None, None, 9, 20]\nnode = TreeNode.from_list(tree_list)\n\n# Initializing BSTIterator with the constructed BST\niterator = BSTIterator(node)\n\n# Making calls to next() and hasNext() and printing the outputs\nprint(iterator.next())    # Expected output: 3\nprint(iterator.next())    # Expected output: 7\nprint(iterator.hasNext())  # Expected output: True\nprint(iterator.next())    # Expected output: 9\nprint(iterator.hasNext())  # Expected output: True\nprint(iterator.next())    # Expected output: 15\nprint(iterator.hasNext())  # Expected output: True\nprint(iterator.next())    # Expected output: 20\nprint(iterator.hasNext())  # Expected output: False']"
"Given the root of a complete binary tree, return the number of nodes in the tree. The algorithm should run in less than O(n) time complexity.",Count nodes in complete tree,"Input: root = [1,2,3,4,5,6] Output: 6; Input: root = [] Output: 0; Input: root = [1] Output: 1","The number of nodes in the tree is in the range [0, 5 * 10^4]. 0 <= Node.val <= 5 * 10^4. The tree is guaranteed to be complete.",https://leetcode.com/problems/Count-Complete-Tree-Nodes/,Count Complete Tree Nodes,Binary Tree - General,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', '# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(\n        self,\n        val: int = 0,\n        left: Optional[TreeNode] = None,\n        right: Optional[TreeNode] = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[TreeNode]:\n        """"""\n        Constructs a binary tree from a list of values using level-order traversal (BFS).\n\n        Parameters:\n        - values (list): The list of values to construct the binary tree from.\n\n        Returns:\n        TreeNode: The root of the constructed binary tree.\n        """"""\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self):\n        """"""\n        Prints the level order traversal of the tree (BFS).\n\n        Returns:\n        list: A list of lists, where each sublist contains the values of the tree nodes\n              at that depth.\n        """"""\n        queue = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            if current_node:\n                current_level.append(current_node.val)\n                queue.append((current_node.left, node_level + 1))\n                queue.append((current_node.right, node_level + 1))\n            else:\n                current_level.append(""None"")\n\n        if current_level:\n            result.append(current_level)\n\n        # Remove trailing ""None"" values\n        result = [level for level in result if any(elem != ""None"" for elem in level)]\n\n        return result', 'class Solution:\n    def countNodes(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        # Count the height of the tree\n        height = 0\n        node = root\n        while node.left:\n            node = node.left\n            height += 1\n\n        # function to check if the node at index exists\n        def node_exists(index: int, height: int, node: Optional[TreeNode]) -> bool:\n            left, right = 0, 2 ** height - 1\n            for _ in range(height):\n                pivot = (left + right) // 2\n                if index <= pivot:\n                    node = node.left\n                    right = pivot\n                else:\n                    node = node.right\n                    left = pivot + 1\n            return node is not None\n\n        # Binary search to find the last existing node\n        left, right = 0, 2 ** height - 1\n        while left <= right:\n            pivot = (left + right) // 2\n            if node_exists(pivot, height, root):\n                left = pivot + 1\n            else:\n                right = pivot - 1\n\n        # The total number of nodes is the sum of the nodes in all levels except the last,\n        # plus the number of nodes in the last level\n        # 2**height - 1 is the number of nodes in all levels except the last\n        # 2^0 + 2^1 + ... + 2^(height-1) = 2^height - 1 (formula for sum of a geometric series)\n        # Sn = a1 * (1 - r^n) / (1 - r), where a1 = 1, r = 2, n = height\n        return (2**height - 1) + left', '# Test\n\ns = Solution()\n\nroot = TreeNode.from_list([1, 2, 3, 4, 5, 6])\nassert s.countNodes(root) == 6\n\nroot = TreeNode.from_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\nassert s.countNodes(root) == 14\n\nroot = TreeNode.from_list([1, 2, 3, 4, 5, 6, 7])\nassert s.countNodes(root) == 7\n\nroot = TreeNode.from_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\nassert s.countNodes(root) == 13\n\nroot = TreeNode.from_list([1])\nassert s.countNodes(root) == 1\n\nroot = TreeNode.from_list([])\nassert s.countNodes(root) == 0']"
"Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.",Find lowest common ancestor,"Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1; Output: 3. Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4; Output: 5. Input: root = [1,2], p = 1, q = 2; Output: 1.","The number of nodes in the tree is in the range [2, 105]. -10^9 <= Node.val <= 10^9. All Node.val are unique. p != q. p and q will exist in the tree.",https://leetcode.com/problems/Lowest-Common-Ancestor-of-a-Binary-Tree/,Lowest Common Ancestor of a Binary Tree,Binary Tree - General,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', '# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(\n        self,\n        val: int = 0,\n        left: Optional[TreeNode] = None,\n        right: Optional[TreeNode] = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[TreeNode]:\n        """"""\n        Constructs a binary tree from a list of values using level-order traversal (BFS).\n\n        Parameters:\n        - values (list): The list of values to construct the binary tree from.\n\n        Returns:\n        TreeNode: The root of the constructed binary tree.\n        """"""\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self):\n        """"""\n        Prints the level order traversal of the tree (BFS).\n\n        Returns:\n        list: A list of lists, where each sublist contains the values of the tree nodes\n              at that depth.\n        """"""\n        queue = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            if current_node:\n                current_level.append(current_node.val)\n                queue.append((current_node.left, node_level + 1))\n                queue.append((current_node.right, node_level + 1))\n            else:\n                current_level.append(""None"")\n\n        if current_level:\n            result.append(current_level)\n\n        # Remove trailing ""None"" values\n        result = [level for level in result if any(elem != ""None"" for elem in level)]\n\n        return result', 'class Solution:\n    def lowestCommonAncestor(\n        self, root: TreeNode, p: TreeNode, q: TreeNode\n    ) -> TreeNode:\n        if not root or root.val == p.val or root.val == q.val:\n            return root\n\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n\n        # if both left and right are not None, then p and q are in different subtrees\n        if left and right:\n            return root\n\n        # else return the non-None child if only one side is non-None, otherwise null\n        return left if left else right', '# Test Cases\n\nsolution = Solution()\n\ntrees = [\n    ([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4], TreeNode(5), TreeNode(1)),\n    ([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4], TreeNode(5), TreeNode(4)),\n    ([1, 2], TreeNode(1), TreeNode(2)),\n    ([6, 2, 8, 0, 4, 7, 9, None, None, 3, 5], TreeNode(2), TreeNode(8)),\n]\n\nfor values, p, q in trees:\n    root = TreeNode.from_list(values)\n    lca = solution.lowestCommonAncestor(root, p, q)\n    print(\n        f\'Test Case with p = {p.val}, q = {q.val}: LCA = {lca.val if lca else ""None""}\'\n    )']"
"Given the root of a binary tree, return the values of the nodes visible from the right side, ordered from top to bottom.",Binary Tree Right Side View,"Input: root = [1,2,3,null,5,null,4] Output: [1,3,4]; Input: root = [1,null,3] Output: [1,3]; Input: root = [] Output: []","The number of nodes in the tree is in the range [0, 100]. -100 <= Node.val <= 100",https://leetcode.com/problems/Binary-Tree-Right-Side-View/,Binary Tree Right Side View,Binary Tree - BFS,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', 'class TreeNode:\n    def __init__(\n        self,\n        val: Optional[int] = 0,\n        left: Optional[""TreeNode""] = None,\n        right: Optional[""TreeNode""] = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[""TreeNode""]:\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue: deque[TreeNode] = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self) -> list[list[Optional[int]]]:\n        queue: deque[tuple[TreeNode, int]] = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            current_level.append(current_node.val)\n            if current_node.left is not None:\n                queue.append((current_node.left, node_level + 1))\n            if current_node.right is not None:\n                queue.append((current_node.right, node_level + 1))\n\n        if current_level:\n            result.append(current_level)\n\n        return result', 'class Solution:\n    # Time Complexity: O(n) - Space Complexity: O(n)\n    def rightSideView(self, root: Optional[TreeNode]) -> list[int]:\n        if not root:\n            return []\n\n        q = deque([root])\n        right_side_view: list[int] = []\n\n        while q:\n            level_length = len(q)\n\n            for i in range(level_length):\n                # Dequeue the current node\n                node = q.popleft()\n\n                if i == level_length - 1 and node.val is not None:\n                    # Add the last node of each level to the result\n                    right_side_view.append(node.val)\n\n                # Enqueue children\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n\n        return right_side_view', '# Test Cases\ns = Solution()\n\nroot1 = TreeNode.from_list([1, 2, 3, None, 5, None, 4])\nroot2 = TreeNode.from_list([1, None, 3])\nroot3 = TreeNode.from_list([])\nroot4 = TreeNode.from_list(\n    [0, 1, 2, None, 3, 4, None, None, 5, 9, None, None, 6, 10, None]\n)\n\nexample1 = s.rightSideView(root1)\nexample2 = s.rightSideView(root2)\nexample3 = s.rightSideView(root3)\nexample4 = s.rightSideView(root4)\n\nexample1, example2, example3, example4']"
"Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10^-5 of the actual answer will be accepted.",Average of binary tree levels,"Input: root = [3,9,20,null,null,15,7] Output: [3.00000,14.50000,11.00000]","The number of nodes in the tree is in the range [1, 10^4]. -2^31 <= Node.val <= 2^31 - 1",https://leetcode.com/problems/Average-of-Levels-in-Binary-Tree/,Average of Levels in Binary Tree,Binary Tree - BFS,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', 'class TreeNode:\n    def __init__(\n        self,\n        val: Optional[int] = 0,\n        left: Optional[""TreeNode""] = None,\n        right: Optional[""TreeNode""] = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[""TreeNode""]:\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue: deque[TreeNode] = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self) -> list[list[Optional[int]]]:\n        queue: deque[tuple[TreeNode, int]] = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            current_level.append(current_node.val)\n            if current_node.left is not None:\n                queue.append((current_node.left, node_level + 1))\n            if current_node.right is not None:\n                queue.append((current_node.right, node_level + 1))\n\n        if current_level:\n            result.append(current_level)\n\n        return result', 'class Solution:\n    def averageOfLevels(self, root: Optional[TreeNode]) -> list[float]:\n        if not root:\n            return []\n\n        queue: deque[tuple[TreeNode, int]] = deque([(root, 0)])\n        result = []\n\n        while queue:\n            current_sum: int = 0\n            current_count = 0\n            current_level = queue[0][1]\n\n            while queue and queue[0][1] == current_level:\n                current_node, node_level = queue.popleft()\n                if current_node.val is not None:\n                    current_sum += current_node.val\n                    current_count += 1\n\n                if current_node.left:\n                    queue.append((current_node.left, node_level + 1))\n                if current_node.right:\n                    queue.append((current_node.right, node_level + 1))\n\n            result.append(current_sum / current_count)\n\n        return result', '# Test\ns = Solution()\n\nroot = TreeNode.from_list([3, 9, 20, None, None, 15, 7])\nprint(s.averageOfLevels(root))  # [3.0, 14.5, 11.0]\n\nroot = TreeNode.from_list([3, 9, 20, 15, 7])\nprint(s.averageOfLevels(root))  # [3.0, 14.5, 11.0]']"
"Given the root of a binary tree, return the level order traversal of its nodes' values from left to right, level by level.",Binary Tree Level Order Traversal,"Input: root = [3,9,20,null,null,15,7] Output: [[3],[9,20],[15,7]]","The number of nodes in the tree is in the range [0, 2000]. -1000 <= Node.val <= 1000",https://leetcode.com/problems/Binary-Tree-Level-Order-Traversal/,Binary Tree Level Order Traversal,Binary Tree - BFS,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', 'class TreeNode:\n    def __init__(\n        self,\n        val: Optional[int] = 0,\n        left: Optional[""TreeNode""] = None,\n        right: Optional[""TreeNode""] = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[""TreeNode""]:\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue: deque[TreeNode] = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self) -> list[list[Optional[int]]]:\n        queue: deque[tuple[TreeNode, int]] = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            current_level.append(current_node.val)\n            if current_node.left is not None:\n                queue.append((current_node.left, node_level + 1))\n            if current_node.right is not None:\n                queue.append((current_node.right, node_level + 1))\n\n        if current_level:\n            result.append(current_level)\n\n        return result', 'class Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> list[list[int]]:\n        if root is None:\n            return []\n\n        result = []\n        queue: deque[tuple[TreeNode, int]] = deque([(root, 0)])\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            # if we moved to the next level\n            if node_level > level_number:\n                # add the current level to the result\n                result.append(current_level)\n                # reset the current level\n                current_level = []\n                # update the level number\n                level_number = node_level\n\n            # add the current node to the current level\n            current_level.append(current_node.val)\n\n            # add the children to the queue\n            if current_node.left is not None:\n                queue.append((current_node.left, node_level + 1))\n            if current_node.right is not None:\n                queue.append((current_node.right, node_level + 1))\n\n        # add the last level to the result\n        if current_level:\n            result.append(current_level)\n\n        return result', '# Test\ns = Solution()\n\nassert s.levelOrder(TreeNode.from_list([3, 9, 20, None, None, 15, 7])) == [\n    [3],\n    [9, 20],\n    [15, 7],\n]\nassert s.levelOrder(TreeNode.from_list([1])) == [[1]]\nassert s.levelOrder(None) == []']"
"Given the root of a binary tree, return the zigzag level order traversal of its nodes' values.",Zigzag level order traversal,"Input: root = [3,9,20,null,null,15,7] Output: [[3],[20,9],[15,7]]","The number of nodes in the tree is in the range [0, 2000]. -100 <= Node.val <= 100",https://leetcode.com/problems/Binary-Tree-Zigzag-Level-Order-Traversal/,Binary Tree Zigzag Level Order Traversal,Binary Tree - BFS,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', 'class TreeNode:\n    def __init__(\n        self,\n        val: Optional[int] = 0,\n        left: Optional[""TreeNode""] = None,\n        right: Optional[""TreeNode""] = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[""TreeNode""]:\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue: deque[TreeNode] = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self) -> list[list[Optional[int]]]:\n        queue: deque[tuple[TreeNode, int]] = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            current_level.append(current_node.val)\n            if current_node.left is not None:\n                queue.append((current_node.left, node_level + 1))\n            if current_node.right is not None:\n                queue.append((current_node.right, node_level + 1))\n\n        if current_level:\n            result.append(current_level)\n\n        return result', ""class Solution:\n    # Time complexity: O(n) - Space complexity: O(n)\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> list[list[int]]:\n        # Base case: if the tree is empty, return an empty list.\n        if not root:\n            return []\n        \n        result = []\n        queue = deque([root])  # Use a deque to facilitate O(1) popleft operations.\n        \n        left_to_right = True\n        while queue:\n            level_size = len(queue)\n            current_level = []\n            \n            for _ in range(level_size):\n                # If traversing left to right, pop from the left of the queue.\n                if left_to_right:\n                    current_node = queue.popleft()\n                    # Append children of the current node to the right end of the queue.\n                    if current_node.left:\n                        queue.append(current_node.left)\n                    if current_node.right:\n                        queue.append(current_node.right)\n                # If traversing right to left, pop from the right of the queue.\n                else:\n                    current_node = queue.pop()\n                    # Append children of the current node to the left end of the queue.\n                    if current_node.right:\n                        queue.appendleft(current_node.right)\n                    if current_node.left:\n                        queue.appendleft(current_node.left)\n                \n                # Add the current node's value to the current level's list.\n                current_level.append(current_node.val)\n                \n            result.append(current_level)\n            left_to_right = not left_to_right\n        \n        return result"", '# Test\n\nsolution = Solution()\n\nroot = TreeNode.from_list([3, 9, 20, None, None, 15, 7])\nprint(solution.zigzagLevelOrder(root))  # Expected: [[3],[20,9],[15,7]]\n\nroot = TreeNode.from_list([1])\nprint(solution.zigzagLevelOrder(root))  # Expected: [[1]]\n\nroot = TreeNode.from_list([])\nprint(solution.zigzagLevelOrder(root))  # Expected: []']"
"Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.",Minimum absolute difference in BST,"Input: root = [4,2,6,1,3] Output: 1; Input: root = [1,0,48,null,null,12,49] Output: 1","The number of nodes in the tree is in the range [2, 10^4]. 0 <= Node.val <= 10^5",https://leetcode.com/problems/Minimum-Absolute-Difference-in-BST/,Minimum Absolute Difference in BST,Binary Tree - BFS,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', 'class TreeNode:\n    def __init__(\n        self,\n        val: Optional[int] = 0,\n        left: Optional[""TreeNode""] = None,\n        right: Optional[""TreeNode""] = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[""TreeNode""]:\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue: deque[TreeNode] = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self) -> list[list[Optional[int]]]:\n        queue: deque[tuple[TreeNode, int]] = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            current_level.append(current_node.val)\n            if current_node.left is not None:\n                queue.append((current_node.left, node_level + 1))\n            if current_node.right is not None:\n                queue.append((current_node.right, node_level + 1))\n\n        if current_level:\n            result.append(current_level)\n\n        return result', 'class Solution:\n    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:\n        self.min_diff = float(""inf"")\n        self.prev: Optional[TreeNode] = None\n\n        def inorder(node: Optional[TreeNode]) -> None:\n            if node is None:\n                return\n\n            # traverse left\n            inorder(node.left)\n\n            # process current node\n            if (\n                self.prev is not None\n                and node.val is not None\n                and self.prev.val is not None\n            ):\n                self.min_diff = min(self.min_diff, node.val - self.prev.val)\n            self.prev = node\n\n            # traverse right\n            inorder(node.right)\n\n        inorder(root)\n        return int(self.min_diff)', '# Test\n\ns = Solution()\n\nroot = TreeNode.from_list([4, 2, 6, 1, 3])\nprint(s.getMinimumDifference(root))  # 1\n\nroot = TreeNode.from_list([1, 0, 48, None, None, 12, 49])\nprint(s.getMinimumDifference(root))  # 1']"
"Given the root of a binary search tree and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.",Kth smallest in BST,"Input: root = [3,1,4,null,2], k = 1; Output: 1. Input: root = [5,3,6,2,4,null,null,1], k = 3; Output: 3.",1 <= k <= n <= 10^4; 0 <= Node.val <= 10^4.,https://leetcode.com/problems/Kth-Smallest-Element-in-BST/,Kth Smallest Element in BST,Binary Tree - BFS,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', 'class TreeNode:\n    def __init__(\n        self,\n        val: Optional[int] = 0,\n        left: Optional[""TreeNode""] = None,\n        right: Optional[""TreeNode""] = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[""TreeNode""]:\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue: deque[TreeNode] = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self) -> list[list[Optional[int]]]:\n        queue: deque[tuple[TreeNode, int]] = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            current_level.append(current_node.val)\n            if current_node.left is not None:\n                queue.append((current_node.left, node_level + 1))\n            if current_node.right is not None:\n                queue.append((current_node.right, node_level + 1))\n\n        if current_level:\n            result.append(current_level)\n\n        return result', 'class Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int):\n        def inorder_traversal(node: Optional[TreeNode]):\n            if node is not None:\n                yield from inorder_traversal(node.left)\n                yield node.val\n                yield from inorder_traversal(node.right)\n\n        # generate inorder sequence and get the kth element\n        inorder = inorder_traversal(root)\n\n        for _ in range(k):\n            result = next(inorder)\n\n        return result', '# Test\n\ns = Solution()\nroot = TreeNode.from_list([3, 1, 4, None, 2])\nprint(s.kthSmallest(root, 1))  # 1\n\nroot = TreeNode.from_list([5, 3, 6, 2, 4, None, None, 1])\nprint(s.kthSmallest(root, 3))  # 3']"
"Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined by the properties of its nodes and their subtrees.",Validate Binary Search Tree,"Input: root = [2,1,3] Output: true; Input: root = [5,1,4,null,null,3,6] Output: false","The number of nodes in the tree is in the range [1, 10^4]. -2^31 <= Node.val <= 2^31 - 1",https://leetcode.com/problems/Validate-Binary-Search-Tree/,Validate Binary Search Tree,Binary Tree - BFS,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', 'class TreeNode:\n    def __init__(\n        self,\n        val: Optional[int] = 0,\n        left: Optional[""TreeNode""] = None,\n        right: Optional[""TreeNode""] = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[""TreeNode""]:\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue: deque[TreeNode] = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self) -> list[list[Optional[int]]]:\n        queue: deque[tuple[TreeNode, int]] = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            current_level.append(current_node.val)\n            if current_node.left is not None:\n                queue.append((current_node.left, node_level + 1))\n            if current_node.right is not None:\n                queue.append((current_node.right, node_level + 1))\n\n        if current_level:\n            result.append(current_level)\n\n        return result', 'class Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        def validate(\n            node: Optional[TreeNode], low=-float(""inf""), high=float(""inf"")\n        ) -> bool:\n            if not node:\n                return True\n\n            # The current node\'s value must be between low and high\n            if (node.val is not None) and not (low < node.val < high):\n                return False\n\n            # Left subtree must have values < node.val, right subtree must have values > node.val\n            return (\n                node.val is not None\n                and validate(node.left, low, node.val)\n                and validate(node.right, node.val, high)\n            )\n\n        return validate(root)', '# Test\n\ns = Solution()\n\nroot = TreeNode.from_list([2, 1, 3])\nassert s.isValidBST(root) == True\nroot = TreeNode.from_list([5, 1, 4, None, None, 3, 6])\nassert s.isValidBST(root) == False']"
"Given an m x n 2D binary grid representing a map of '1's (land) and '0's (water), return the number of islands formed by connecting adjacent lands horizontally or vertically.",Count number of islands,"Input: [['1','1','1','1','0'], ['1','1','0','1','0'], ['1','1','0','0','0'], ['0','0','0','0','0']] Output: 1; Input: [['1','1','0','0','0'], ['1','1','0','0','0'], ['0','0','1','0','0'], ['0','0','0','1','1']] Output: 3","1 <= m, n <= 300; grid[i][j] is '0' or '1'.",https://leetcode.com/problems/Number-of-Islands/,Number of Islands,Graph - General,"['class Solution:\n    # Time complexity: O(M * N) - Space complexity: O(M * N) from the call stack\n    def numIslands(self, grid: list[list[str]]) -> int:\n        # edge case\n        if not grid:\n            return 0\n\n        # get the number of rows and columns\n        rows, cols = len(grid), len(grid[0])\n\n        # count the number of islands\n        num_islands = 0\n\n        # dfs function\n        def dfs(row: int, col: int) -> None:\n            # base case: if the current cell is out of the grid (water) or is water\n            if (\n                row < 0\n                or col < 0\n                or row >= rows\n                or col >= cols\n                or grid[row][col] == ""0""\n            ):\n                return\n            # mark the current cell as visited\n            grid[row][col] = ""0""\n            # visit the neighbors\n            dfs(row + 1, col)  # down\n            dfs(row - 1, col)  # up\n            dfs(row, col + 1)  # right\n            dfs(row, col - 1)  # left\n\n        for row in range(rows):\n            for col in range(cols):\n                if grid[row][col] == ""1"":  # Found an unvisited cell\n                    num_islands += 1\n                    dfs(row, col)\n\n        return num_islands', '# Example 1\ngrid1 = [\n    [""1"", ""1"", ""1"", ""1"", ""0""],\n    [""1"", ""1"", ""0"", ""1"", ""0""],\n    [""1"", ""1"", ""0"", ""0"", ""0""],\n    [""0"", ""0"", ""0"", ""0"", ""0""],\n]\n\n# Example 2\ngrid2 = [\n    [""1"", ""1"", ""0"", ""0"", ""0""],\n    [""1"", ""1"", ""0"", ""0"", ""0""],\n    [""0"", ""0"", ""1"", ""0"", ""0""],\n    [""0"", ""0"", ""0"", ""1"", ""1""],\n]\n\ns = Solution()\n\noutput1 = s.numIslands(grid1)\noutput2 = s.numIslands(grid2)\n\noutput1, output2']"
"Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X' by flipping all 'O's into 'X's in that surrounded region.",Capture surrounded regions in matrix,"Input: board = [['X', 'X', 'X', 'X'], ['X', 'O', 'O', 'X'], ['X', 'X', 'O', 'X'], ['X', 'O', 'X', 'X']]; Output: board = [['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'O', 'X', 'X']]","1 <= m, n <= 200; board[i][j] is 'X' or 'O'.",https://leetcode.com/problems/Surrounded-Regions/,Surrounded Regions,Graph - General,"[""class Solution:\n    # DFS approach - Time complexity: O(m*n) - Space complexity: O(m*n)\n    def solve(self, board: list[list[str]]) -> None:\n        if not board:\n            return\n\n        rows, cols = len(board), len(board[0])\n\n        # Mark 'O's connected to boundary as '#'\n        def dfs(r, c):\n            if 0 <= r < rows and 0 <= c < cols and board[r][c] == 'O':\n                board[r][c] = '#'  # Mark as visited\n                dfs(r + 1, c)\n                dfs(r - 1, c)\n                dfs(r, c + 1)\n                dfs(r, c - 1)\n\n        # Mark from the boundary\n        for r in range(rows):\n            for c in range(cols):\n                # Check if it's a boundary 'O'\n                if (r in [0, rows - 1] or c in [0, cols - 1]) and board[r][c] == 'O':\n                    # Mark connected 'O's as '#'\n                    dfs(r, c)\n\n        # Replace surrounded 'O's with X's, restore marked 'O's by replacing '#' with 'O'\n        for r in range(rows):\n            for c in range(cols):\n                if board[r][c] == 'O':\n                    board[r][c] = 'X'\n                elif board[r][c] == '#':\n                    board[r][c] = 'O'"", '# Test Cases\n\nboard = [\n    [""X"", ""X"", ""X"", ""X""],\n    [""X"", ""X"", ""X"", ""X""],\n    [""X"", ""X"", ""X"", ""X""],\n    [""X"", ""O"", ""X"", ""X""],\n]\n\ns = Solution()\ns.solve(board)\n\nfor row in board:\n    print(row)']"
Create a deep copy of a connected undirected graph given an adjacency list.,Clone a connected graph,"Input: adjList = [[2,4],[1,3],[2,4],[1,3]]; Output: [[2,4],[1,3],[2,4],[1,3]]",0 <= Number of nodes <= 100; 1 <= Node.val <= 100; Node.val is unique; The graph is connected; No self-loops or repeated edges exist.,https://leetcode.com/problems/Clone-Graph/,Clone Graph,Graph - General,"['# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors: list[""Node""] | None = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n', 'from typing import Optional\n\n\nclass Solution:\n    def cloneGraph(self, node: Optional[Node]) -> Optional[Node]:\n        # hash map to store the original node and the cloned node\n        visited: dict[Node, Node] = {}\n\n        def dfs(node: Optional[Node]) -> Optional[Node]:\n            # Base case: handle null input\n            if not node:\n                return None\n\n            # Return existing copy if node already cloned\n            if node in visited:\n                return visited[node]\n\n            # create a new node\n            clone_node = Node(node.val)\n\n            # Mark the copy as visited\n            visited[node] = clone_node\n\n            # Recursively clone neighbors and link them\n            for neighbor in node.neighbors:\n                clone_node.neighbors.append(dfs(neighbor))\n\n            return clone_node\n\n        # Start cloning from the input node\n        return dfs(node)']"
What is the space complexity of using Depth-First Search (DFS) to solve the 'Evaluate Division' problem?,Space complexity of DFS,"Input: equations = [['a', 'b'], ['b', 'c']], values = [2.0, 3.0], queries = [['a', 'c'], ['b', 'a'], ['a', 'e'], ['a', 'a'], ['x', 'x']]. Output: [6.0, 0.5, -1.0, 1.0, -1.0]",E and Q can be up to 20.,https://leetcode.com/problems/Evaluate-Division/,Evaluate Division,Graph - General,"['from collections import defaultdict\n\n\nclass Solution:\n    def calcEquation(self, equations: list[list[str]], values: list[float], queries: list[list[str]]) -> list[float]:\n        # build graph from equations\n        graph: defaultdict[str, dict[str, float]] = defaultdict(dict)\n        for (a, b), value in zip(equations, values):\n            graph[a][b] = value\n            graph[b][a] = 1 / value\n\n        # function to find path from source to target\n        def dfs(source: str, target: str, visited: set[str]) -> float:\n            # edge case 1: source or target not in graph\n            if source not in graph or target not in graph:\n                return -1.0\n            # edge case 2: source == target\n            if source == target:\n                return 1.0\n\n            # mark source as visited\n            visited.add(source)\n\n            # iterate over neighbors of source\n            for neighbor, value in graph[source].items():\n                # skip if neighbor already visited\n                if neighbor in visited:\n                    continue\n                # mark neighbor as visited\n                visited.add(neighbor)\n                # recursive call\n                product = dfs(neighbor, target, visited)\n                # return if path found\n                if product != -1.0:\n                    return value * product\n\n            return -1.0\n\n        # iterate over queries\n        result: list[float] = []\n        for source, target in queries:\n            if source not in graph or target not in graph:\n                result.append(-1.0)\n            elif source == target:\n                result.append(1.0)\n            else:\n                result.append(dfs(source, target, set()))\n\n        return result']"
Can you finish all courses given prerequisites?,Course schedule completion check,"Input: numCourses = 2, prerequisites = [[1,0]]; Output: true","1 <= numCourses <= 2000; 0 <= prerequisites.length <= 5000; prerequisites[i].length == 2; 0 <= ai, bi < numCourses; All pairs in prerequisites[i] are unique.",https://leetcode.com/problems/Course-Schedule/,Course Schedule,Graph - General,"['from collections import deque\n\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: list[list[int]]) -> bool:\n        # create a list to store the number of prerequisites for each course\n        in_degree = [0] * numCourses\n        # create an adjacency list to store the courses that can be taken\n        graph = [[] for _ in range(numCourses)]\n\n        # build the graph and in_degree list\n        for course, pre in prerequisites:\n            graph[pre].append(course)\n            in_degree[course] += 1\n\n        # create a queue to store the courses that can be taken - starting with the courses that have no prerequisites\n        queue = deque([i for i in range(numCourses) if in_degree[i] == 0])\n        # create a counter to keep track of the number of courses processed\n        visited = 0\n\n        # process the graph\n        while queue:\n            course = queue.popleft()\n            visited += 1\n            # reduce the number of prerequisites for the courses that can be taken\n            for c in graph[\n                course\n            ]:  # c is the course that can be taken - neighbors of the course\n                in_degree[c] -= 1\n                # add the course to the queue if it has no prerequisites\n                if in_degree[c] == 0:\n                    queue.append(c)\n\n        # if all the courses can be taken, return True\n        return visited == numCourses', 's = Solution()\n\nprint(s.canFinish(2, [[1, 0]]))  # Output: True\nprint(s.canFinish(2, [[1, 0], [0, 1]]))  # Output: False']"
"Given numCourses and prerequisites, find a valid order to complete all courses or return an empty array if impossible.",Course scheduling with prerequisites,"Input: numCourses = 2, prerequisites = [[1,0]]; Output: [0,1]","1 <= numCourses <= 2000; 0 <= prerequisites.length <= numCourses * (numCourses - 1); prerequisites[i].length == 2; 0 <= ai, bi < numCourses; ai != bi; All pairs [ai, bi] are distinct.",https://leetcode.com/problems/Course-Schedule-II/,Course Schedule II,Graph - General,"['from collections import deque\n\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: list[list[int]]) -> list[int]:\n        # create a list to store the number of prerequisites for each course\n        in_degree = [0] * numCourses\n        # create an adjacency list to store the courses that can be taken\n        graph = [[] for _ in range(numCourses)]\n\n        # build the graph and in_degree list\n        for course, pre in prerequisites:\n            graph[pre].append(course)\n            in_degree[course] += 1\n\n        # create a queue to store the courses that can be taken - starting with the courses that have no prerequisites (in_degree = 0)\n        queue = deque([i for i in range(numCourses) if in_degree[i] == 0])\n        # create a list to keep track of the order of the courses that can be taken\n        topological_order: list[int] = []\n\n        # process the graph\n        while queue:\n            course = queue.popleft()\n            topological_order.append(course)\n            # reduce the number of prerequisites for the courses that can be taken (reduce the in_degree of neighbors)\n            for c in graph[\n                course\n            ]:  # c is the course that can be taken - neighbors of the course\n                in_degree[c] -= 1\n                # add the course to the queue if it has no prerequisites (in_degree = 0)\n                if in_degree[c] == 0:\n                    queue.append(c)\n\n        # if all the courses can be taken => Check if topological sorting is possible (i.e., no cycle)\n        if len(topological_order) == numCourses:\n            return topological_order\n        else:\n            return []', '# Test cases\ns = Solution()\n\ntest_cases = [(2, [[1, 0]]), (4, [[1, 0], [2, 0], [3, 1], [3, 2]]), (1, [])]\n\n[s.findOrder(numCourses, prerequisites) for numCourses, prerequisites in test_cases]']"
"Given an n x n board, determine the minimum number of moves to reach the last square, considering snakes and ladders.",Snakes and Ladders game,"Input: board = [[-1,-1],[-1,3]]; Output: 1","2 <= n <= 20; board[i][j] is either -1 or in the range [1, n^2]; squares 1 and n^2 do not have snakes or ladders.",https://leetcode.com/problems/Snakes-and-Ladders/,Snakes and Ladders,Graph - BFS,"[""from collections import deque\n\n\nclass Solution:\n    def snakesAndLadders(self, board: list[list[int]]) -> int:\n        n = len(board)\n\n        # Function to convert the square number to board indices\n        def get_position(square):\n            row = (square - 1) // n\n            col = (square - 1) % n\n            if row % 2 == 1:  # if the row is odd, reverse the order of columns\n                col = n - 1 - col\n            row = n - 1 - row  # reverse the row to start from the bottom\n            return row, col\n\n        # BFS setup\n        queue = deque([1])  # start BFS from square 1\n        visited = set([1])\n        moves: int = 0\n\n        # BFS loop\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                current = queue.popleft()\n                if current == n * n:  # reached the last square\n                    return moves\n                # Explore the next moves for dice rolls from 1 to 6\n                for dice_roll in range(1, 7):\n                    next_square = current + dice_roll\n                    if (\n                        next_square > n * n\n                    ):  # skip if next square is beyond board limits\n                        continue\n                    r, c = get_position(next_square)\n                    # If there is a snake or ladder, take it\n                    if board[r][c] != -1:\n                        next_square = board[r][c]\n\n                    if next_square not in visited:\n                        visited.add(next_square)\n                        queue.append(next_square)\n            moves += 1\n\n        # If it's not possible to reach the last square\n        return -1"", '# Test the implementation\n\ns = Solution()\n\nboard_example1 = [\n    [-1, -1, -1, -1, -1, -1],\n    [-1, -1, -1, -1, -1, -1],\n    [-1, -1, -1, -1, -1, -1],\n    [-1, 35, -1, -1, 13, -1],\n    [-1, -1, -1, -1, -1, -1],\n    [-1, 15, -1, -1, -1, -1],\n]\nboard_example2 = [[-1, -1], [-1, 3]]\n\n# Execute test cases\noutput1 = s.snakesAndLadders(board_example1)  # Expected output: 4\noutput2 = s.snakesAndLadders(board_example2)  # Expected output: 1\n\noutput1, output2']"
What is the time and space complexity of generating mutations for gene strings?,Time and space complexity analysis,"Input: gene bank = ['AACCGGTA', 'AACCGGTT', 'AACCGGTC'], startGene = 'AACCGGTA'; Output: Time complexity O(N), Space complexity O(N)",Maximum bank size is limited to 10.,https://leetcode.com/problems/Minimum-Genetic-Mutation/,Minimum Genetic Mutation,Graph - BFS,"['from collections import deque\n\n\nclass Solution:\n    def minMutation(self, startGene: str, endGene: str, bank: list[str]) -> int:\n        # handle edge case\n        if startGene == endGene:\n            return 0\n        if endGene not in bank:\n            return -1\n\n        # convert bank to set for faster lookup\n        bank: set[str] = set(bank)\n        # create a queue to store the genes to be visited\n        # (current gene, number of mutations)\n        queue: deque[tuple[str, int]] = deque([(startGene, 0)])\n        # create a set to store the visited gene\n        visited = set([startGene])\n\n        while queue:\n            current_gene, mutation_count = queue.popleft()\n\n            # generate all possible mutations of the current gene\n            for i in range(len(current_gene)):\n                for c in ""ACGT"":\n                    if c != current_gene[i]:\n                        new_gene = current_gene[:i] + c + current_gene[i+1:]\n                        if new_gene == endGene:\n                            return mutation_count + 1\n                        if new_gene in bank and new_gene not in visited:\n                            queue.append((new_gene, mutation_count + 1))\n                            visited.add(new_gene)\n\n        # if no valid mutation sequence is found\n        return -1', '# Testing the function with the given examples\n\ns = Solution()\n\nexample1 = s.minMutation(""AACCGGTT"", ""AACCGGTA"", [""AACCGGTA""])\nexample2 = s.minMutation(\n    ""AACCGGTT"", ""AAACGGTA"", [""AACCGGTA"", ""AACCGCTA"", ""AAACGGTA""])\n\nexample1, example2']"
"Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.",Word ladder transformation length,"Input: beginWord = ""hit"", endWord = ""cog"", wordList = [""hot"",""dot"",""dog"",""lot"",""log"",""cog""]
Output: 5

Input: beginWord = ""hit"", endWord = ""cog"", wordList = [""hot"",""dot"",""dog"",""lot"",""log""]
Output: 0",1 <= beginWord.length <= 10; endWord.length == beginWord.length; 1 <= wordList.length <= 5000; wordList[i].length == beginWord.length; beginWord != endWord; All words in wordList are unique.,https://leetcode.com/problems/Word-Ladder/,Word Ladder,Graph - BFS,"['from collections import deque\n\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: list[str]) -> int:\n        if endWord not in wordList:\n            return 0\n\n        L = len(beginWord)\n        all_combo_dict = {}\n\n        # Preprocessing to build the all_combo_dict dictionary.\n        for word in wordList:\n            for i in range(L):\n                generic_word = word[:i] + ""*"" + word[i + 1:]\n                if generic_word in all_combo_dict:\n                    all_combo_dict[generic_word].append(word)\n                else:\n                    all_combo_dict[generic_word] = [word]\n\n        # BFS initialization\n        queue: deque[tuple[str, int]] = deque([(beginWord, 1)])\n        visited: set[str] = {beginWord}\n\n        # BFS loop\n        while queue:\n            current_word, level = queue.popleft()\n            for i in range(L):\n                # Intermediate words for current_word\n                generic_word = current_word[:i] + ""*"" + current_word[i + 1:]\n                for word in all_combo_dict.get(generic_word, []):\n                    if word == endWord:\n                        return level + 1\n                    if word not in visited:\n                        visited.add(word)\n                        queue.append((word, level + 1))\n                # clear the list to prevent reprocessing\n                all_combo_dict[generic_word] = []\n\n        return 0', '# Test cases\n\ns = Solution()\n\ntest_cases = [\n    (""hit"", ""cog"", [""hot"", ""dot"", ""dog"", ""lot"", ""log"", ""cog""]),  # Expected: 5\n    (""hit"", ""cog"", [""hot"", ""dot"", ""dog"", ""lot"", ""log""]),  # Expected: 0\n    (""cat"", ""dog"", [""cot"", ""cog"", ""dog""]),  # Expected: 4\n    # Expected: 0, as there is no connection to \'def\'\n    (""abc"", ""def"", [""abd"", ""aec"", ""afc"", ""bfc""]),\n    (\n        ""game"",\n        ""thus"",\n        [""gape"", ""gare"", ""gase"", ""gate"", ""hate"", ""have"", ""hose"", ""huse"", ""thus""],\n    ),  # Expected to find a short path\n]\n\n# Execute test cases\nresults = []\nfor begin, end, word_list in test_cases:\n    result = s.ladderLength(begin, end, word_list)\n    results.append(result)\n\nresults']"
"Implement the Trie class with methods to insert a word, search for a word, and check if any word starts with a given prefix.",Implement Trie data structure,"Input: ['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']] Output: [null, null, true, false, true, null, true]","1 <= word.length, prefix.length <= 2000; word and prefix consist only of lowercase English letters; at most 3 * 10^4 calls in total.",https://leetcode.com/problems/Implement-Trie-(Prefix-Tree)/,Implement Trie (Prefix Tree),Trie,"['class TrieNode:\n    def __init__(self):\n        # Each TrieNode contains a dictionary of children nodes and a boolean to indicate if it\'s the end of a word\n        self.children = {}\n        self.is_end_of_word = False\n\n\nclass Trie:\n    def __init__(self):\n        """"""\n        Initialize your data structure here. The root node is initialized and doesn\'t contain any character.\n        """"""\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        """"""\n        Inserts a word into the trie.\n\n        Args:\n        word (str): The word to insert into the trie.\n        """"""\n        current_node = self.root\n        for char in word:\n            # If the character is not already a child of the current node, create a new TrieNode for it\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            # Move to the child node associated with the character\n            current_node = current_node.children[char]\n        # Mark the end of the word at the last node\n        current_node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        """"""\n        Returns if the word is in the trie.\n\n        Args:\n        word (str): The word to search for in the trie.\n\n        Returns:\n        bool: True if the word exists in the trie, False otherwise.\n        """"""\n        current_node = self.root\n        for char in word:\n            # If the character is not found among the children, the word doesn\'t exist in the trie\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        # Return True only if the current node marks the end of the word\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        """"""\n        Returns if there is any word in the trie that starts with the given prefix.\n\n        Args:\n        prefix (str): The prefix to check in the trie.\n\n        Returns:\n        bool: True if any word in the trie starts with the prefix, False otherwise.\n        """"""\n        current_node = self.root\n        for char in prefix:\n            # If the character is not found among the children, no word starts with this prefix\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        # A node exists for every character in the prefix, so return True\n        return True', 'def test_trie():\n    trie = Trie()\n\n    # Test case scenario\n    operations = [\n        ""Trie"",\n        ""insert"",\n        ""search"",\n        ""search"",\n        ""startsWith"",\n        ""insert"",\n        ""search"",\n    ]\n    values = [[], [""apple""], [""apple""], [""app""], [""app""], [""app""], [""app""]]\n    expected_outputs = [None, None, True, False, True, None, True]\n\n    # Initialize outputs array for collecting actual results\n    outputs = []\n\n    # Process each operation\n    for operation, value in zip(operations, values):\n        if operation == ""Trie"":\n            trie = Trie()  # Initialize the Trie\n            outputs.append(None)\n        elif operation == ""insert"":\n            trie.insert(value[0])\n            outputs.append(None)\n        elif operation == ""search"":\n            result = trie.search(value[0])\n            outputs.append(result)\n        elif operation == ""startsWith"":\n            result = trie.startsWith(value[0])\n            outputs.append(result)\n\n    # Check if outputs match the expected outputs\n    assert (\n        outputs == expected_outputs\n    ), f""Test failed: Expected {expected_outputs} but got {outputs}""\n    print(""All tests passed!"")\n\n\ntest_trie()']"
"Design a data structure that supports adding new words and finding if a string matches any previously added string, using the `WordDictionary` class with methods `addWord` and `search`.",Add and search words structure,"Input: [""WordDictionary"",""addWord"",""addWord"",""addWord"",""search"",""search"",""search"",""search""] [[],[""bad""],[""dad""],[""mad""],[""pad""],[""bad""],["".ad""],[""b..""]]; Output: [null,null,null,null,false,true,true,true]",1 <= word.length <= 25; word in addWord consists of lowercase English letters; word in search consists of '.' or lowercase English letters; at most 2 dots in word for search queries; at most 10^4 calls to addWord and search.,https://leetcode.com/problems/Design-Add-and-Search-Words-Data-Structure/,Design Add and Search Words Data Structure,Trie,"[""class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\n\nclass WordDictionary:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        def search_in_node(word, node):\n            for i, char in enumerate(word):\n                if char == '.':\n                    # if the current character is '.', check all possible nodes at this level\n                    return any(search_in_node(word[i + 1:], child) for child in node.children.values())\n                else:\n                    if char not in node.children:\n                        # if the current character is not '.' and it's not in the children, then the word doesn't exist\n                        return False\n                    node = node.children[char]\n            return node.is_end_of_word\n\n        return search_in_node(word, self.root)"", 'def run_tests():\n    # Create a new WordDictionary instance\n    word_dictionary = WordDictionary()\n\n    # Add words to the dictionary\n    word_dictionary.addWord(""bad"")\n    word_dictionary.addWord(""dad"")\n    word_dictionary.addWord(""mad"")\n    \n    # Test cases for exact matches and wildcard searches\n    assert not word_dictionary.search(""pad""), ""Expected False, \'pad\' does not exist""\n    assert word_dictionary.search(""bad""), ""Expected True, \'bad\' exists""\n    assert word_dictionary.search("".ad""), ""Expected True, \'.ad\' matches \'bad\', \'dad\', and \'mad\'""\n    assert word_dictionary.search(""b..""), ""Expected True, \'b..\' matches \'bad\'""\n    assert word_dictionary.search(""m..""), ""Expected True, \'m..\' matches \'mad\'""\n    assert word_dictionary.search(""d.d""), ""Expected True, \'d.d\' matches \'dad\'""\n    assert not word_dictionary.search(""da""), ""Expected False, \'da\' is incomplete""\n\n    print(""All tests passed!"")\n\n# Run the test cases\nrun_tests()\n']"
"Given an m x n board of characters and a list of strings words, return all words on the board that can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.",Find words on board,"Input: board = [[""o"",""a"",""a"",""n""],[""e"",""t"",""a"",""e""],[""i"",""h"",""k"",""r""],[""i"",""f"",""l"",""v""]], words = [""oath"",""pea"",""eat"",""rain""]
Output: [""eat"",""oath""]

Input: board = [[""a"",""b""],[""c"",""d""]], words = [""abcb""]
Output: []","1 <= m, n <= 12; 1 <= words.length <= 3 * 10^4; 1 <= words[i].length <= 10; board[i][j] is a lowercase English letter; all strings in words are unique.",https://leetcode.com/problems/Word-Search-II/,Word Search II,Trie,"['from typing import Any\n\n\nclass Solution:\n    def findWords(self, board: list[list[str]], words: list[str]) -> list[str]:\n        WORD_KEY = ""$""\n\n        # Construct the trie from the input words\n        trie = {}\n        for word in words:\n            node = trie\n            for letter in word:\n                # Retrieve the node or create a child node if it does not exist\n                node = node.setdefault(letter, {})\n            # Mark the end of a word in the trie\n            node[WORD_KEY] = word\n\n        row_num = len(board)\n        col_num = len(board[0])\n        matched_words = set()\n\n        def backtracking(row, col, parent_node: dict[str, dict[str, dict[str, Any]]]):\n            letter = board[row][col]\n            curr_node = parent_node[letter]\n\n            # check if we found a word in the trie\n            word_match = curr_node.pop(WORD_KEY, False)\n            if word_match:\n                matched_words.add(word_match)\n\n            # mark the current letter before the EXPLORATION\n            board[row][col] = ""#""\n\n            # Explore the neighbors in 4 directions\n            for row_offset, col_offset in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\n                new_row, new_col = row + row_offset, col + col_offset\n                if (\n                    0 <= new_row < row_num\n                    and 0 <= new_col < col_num\n                    and board[new_row][new_col] in curr_node\n                ):\n                    backtracking(new_row, new_col, curr_node)\n\n            # End of EXPLORATION, restore the original letter in the board\n            board[row][col] = letter\n\n            # Optimization: incrementally remove the matched leaf node in Trie\n            if not curr_node:\n                parent_node.pop(letter)\n\n        for row in range(row_num):\n            for col in range(col_num):\n                # start the dfs from each cell if the letter is in the trie\n                if board[row][col] in trie:\n                    backtracking(row, col, trie)\n\n        return list(matched_words)', 'board = [\n    [""o"", ""a"", ""a"", ""n""],\n    [""e"", ""t"", ""a"", ""e""],\n    [""i"", ""h"", ""k"", ""r""],\n    [""i"", ""f"", ""l"", ""v""],\n]\nwords = [""oath"", ""pea"", ""eat"", ""rain""]\ns = Solution()\nprint(s.findWords(board, words))  # Output: [""eat"", ""oath""]']"
"Given a string of digits from 2-9, return all possible letter combinations that the number could represent based on telephone mappings.",Letter combinations from digits,"Input: digits = '23' Output: ['ad','ae','af','bd','be','bf','cd','ce','cf']","0 <= digits.length <= 4; digits[i] is in ['2', '9']",https://leetcode.com/problems/Letter-Combination-of-a-Phone-Number/,Letter Combination of a Phone Number,Backtracking,"['class Solution:\n    def letterCombinations(self, digits: str) -> list[str]:\n        if not digits:\n            return []\n\n        digit_to_letters = {\n            ""2"": ""abc"",\n            ""3"": ""def"",\n            ""4"": ""ghi"",\n            ""5"": ""jkl"",\n            ""6"": ""mno"",\n            ""7"": ""pqrs"",\n            ""8"": ""tuv"",\n            ""9"": ""wxyz"",\n        }\n\n        combinations = []\n\n        def backtrack(index: int, path: list[str]):\n            if index == len(digits):\n                combinations.append("""".join(path))\n                return\n\n            letters = digit_to_letters[digits[index]]\n            for letter in letters:\n                path.append(letter)\n                backtrack(index + 1, path)\n                path.pop()\n\n        backtrack(0, [])\n\n        return combinations', 's = Solution()\n\n# Test Case 1: Normal case with two digits\ninput_digits = ""23""\nexpected_output = [""ad"", ""ae"", ""af"", ""bd"", ""be"", ""bf"", ""cd"", ""ce"", ""cf""]\nresult = s.letterCombinations(input_digits)\nprint(""Test Case 1 - Expected:"", expected_output)\nprint(""Test Case 1 - Result:"", result)\nprint(""Test Case 1 - Pass:"", sorted(result) == sorted(expected_output))\n\n# Test Case 2: Empty input string\ninput_digits = """"\nexpected_output = []\nresult = s.letterCombinations(input_digits)\nprint(""Test Case 2 - Expected:"", expected_output)\nprint(""Test Case 2 - Result:"", result)\nprint(""Test Case 2 - Pass:"", result == expected_output)\n\n# Test Case 3: Single digit\ninput_digits = ""2""\nexpected_output = [""a"", ""b"", ""c""]\nresult = s.letterCombinations(input_digits)\nprint(""Test Case 3 - Expected:"", expected_output)\nprint(""Test Case 3 - Result:"", result)\nprint(""Test Case 3 - Pass:"", sorted(result) == sorted(expected_output))\n\n# Test Case 4: All unique digits\ninput_digits = ""279""\nexpected_output = [""apw"", ""apx"", ""apy"", ""apz"", ""aqw"", ""aqx"", ""aqy"", ""aqz"", ""arw"", ""arx"", ""ary"", ""arz"", ""asw"", ""asx"", ""asy"", ""asz"",\n                   ""bpw"", ""bpx"", ""bpy"", ""bpz"", ""bqw"", ""bqx"", ""bqy"", ""bqz"", ""brw"", ""brx"", ""bry"", ""brz"", ""bsw"", ""bsx"", ""bsy"", ""bsz"",\n                   ""cpw"", ""cpx"", ""cpy"", ""cpz"", ""cqw"", ""cqx"", ""cqy"", ""cqz"", ""crw"", ""crx"", ""cry"", ""crz"", ""csw"", ""csx"", ""csy"", ""csz""]\nresult = s.letterCombinations(input_digits)\nprint(""Test Case 4 - Expected:"", expected_output)\nprint(""Test Case 4 - Result:"", result)\nprint(""Test Case 4 - Pass:"", sorted(result) == sorted(expected_output))\n\n# Test Case 5: Four digits\ninput_digits = ""2345""\nexpected_output = [\'adgj\', \'adgk\', \'adgl\', \'adhj\', \'adhk\', \'adhl\', \'adij\', \'adik\', \'adil\',\n                   \'aegj\', \'aegk\', \'aegl\', \'aehj\', \'aehk\', \'aehl\', \'aeij\', \'aeik\', \'aeil\',\n                   \'afgj\', \'afgk\', \'afgl\', \'afhj\', \'afhk\', \'afhl\', \'afij\', \'afik\', \'afil\',\n                   \'bdgj\', \'bdgk\', \'bdgl\', \'bdhj\', \'bdhk\', \'bdhl\', \'bdij\', \'bdik\', \'bdil\',\n                   \'begj\', \'begk\', \'begl\', \'behj\', \'behk\', \'behl\', \'beij\', \'beik\', \'beil\',\n                   \'bfgj\', \'bfgk\', \'bfgl\', \'bfhj\', \'bfhk\', \'bfhl\', \'bfij\', \'bfik\', \'bfil\',\n                   \'cdgj\', \'cdgk\', \'cdgl\', \'cdhj\', \'cdhk\', \'cdhl\', \'cdij\', \'cdik\', \'cdil\',\n                   \'cegj\', \'cegk\', \'cegl\', \'cehj\', \'cehk\', \'cehl\', \'ceij\', \'ceik\', \'ceil\',\n                   \'cfgj\', \'cfgk\', \'cfgl\', \'cfhj\', \'cfhk\', \'cfhl\', \'cfij\', \'cfik\', \'cfil\']\nresult = s.letterCombinations(input_digits)\nprint(""Test Case 5 - Expected:"", expected_output)\nprint(""Test Case 5 - Result:"", result)\nprint(""Test Case 5 - Pass:"", sorted(result) == sorted(expected_output))\n']"
What are the time and space complexities of the backtracking approach for generating combinations?,Time and space complexity analysis,"Input: n = 5, k = 3; Output: O(C(5, 3) * 3)",n and k are non-negative integers.,https://leetcode.com/problems/Combinations/,Combinations,Backtracking,"['class Solution:\n    def combine(self, n: int, k: int) -> list[list[int]]:\n        res: list[list[int]] = []\n\n        def backtrack(start: int, curr_combo: list[int]):\n            if len(curr_combo) == k:\n                res.append(curr_combo[:])\n                return\n            for i in range(start, n + 1):\n                curr_combo.append(i)\n                backtrack(i + 1, curr_combo)\n                curr_combo.pop()\n\n        backtrack(1, [])\n        return res', 's = Solution()\n\ntest_cases = [\n    (4, 2),  # Example 1 from the problem statement\n    (1, 1),  # Example 2 from the problem statement\n    (5, 3),  # Larger n and moderate k\n    (3, 3),  # n equals k\n    (5, 0)   # k is zero, should return empty combination\n]\n\n# Run test cases\nresults = [s.combine(n, k) for n, k in test_cases]\nresults']"
"Given an array nums of distinct integers, return all the possible permutations.",Generate all permutations,"Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",1 <= nums.length <= 6; -10 <= nums[i] <= 10; All integers in nums are unique.,https://leetcode.com/problems/Permutations/,Permutations,Backtracking,"['class Solution:\n    def permute(self, nums: list[int]) -> list[list[int]]:\n        res: list[list[int]] = []\n\n        def backtrack(start: int, end: int):\n            if start == end:\n                res.append(nums[:])\n                return\n            for i in range(start, end):\n                # swap to generate a new permutation\n                nums[start], nums[i] = nums[i], nums[start]\n                # recursively generate the rest of the permutation\n                backtrack(start + 1, end)\n                # swap back to the original list\n                nums[start], nums[i] = nums[i], nums[start]\n\n        res = []\n        backtrack(0, len(nums))\n        return res', 's = Solution()\n\n# Example usages:\nnums1 = [1, 2, 3]\nprint(s.permute(nums1))\n\nnums2 = [0, 1]\nprint(s.permute(nums2))\n\nnums3 = [1]\nprint(s.permute(nums3))']"
"Given an array of distinct integers 'candidates' and a target integer 'target', return a list of all unique combinations of 'candidates' where the chosen numbers sum to 'target'. The same number may be chosen multiple times.",Find unique combinations summing to target,"Input: candidates = [2,3,6,7], target = 7; Output: [[2,2,3],[7]]",1 <= candidates.length <= 30; 2 <= candidates[i] <= 40; All elements of candidates are distinct; 1 <= target <= 40,https://leetcode.com/problems/Combination-Sum/,Combination Sum,Backtracking,"['class Solution:\n    def combinationSum(self, candidates: list[int], target: int) -> list[list[int]]:\n        res: list[list[int]] = []\n\n        def backtrack(start: int, target: int, path: list[int]):\n            if target == 0:\n                res.append(path[:])\n                return\n\n            if target < 0:\n                return\n\n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, target - candidates[i], path)\n                path.pop()\n\n        backtrack(0, target, [])\n        return res', '# Test cases\n\ns = Solution()\n\ncandidates1 = [2, 3, 6, 7]\ntarget1 = 7\nprint(s.combinationSum(candidates1, target1))  # Output: [[2,2,3],[7]]\n\ncandidates2 = [2, 3, 5]\ntarget2 = 8\nprint(s.combinationSum(candidates2, target2))  # Output: [[2,2,2,2],[2,3,3],[3,5]]\n\ncandidates3 = [2]\ntarget3 = 1\nprint(s.combinationSum(candidates3, target3))  # Output: []']"
"Given an integer n, return the number of distinct solutions to the n-queens puzzle where n queens are placed on an n x n chessboard such that no two queens attack each other.",Count distinct N-Queens solutions,"Input: n = 4, Output: 2; Input: n = 1, Output: 1",1 <= n <= 9,https://leetcode.com/problems/N-Queens-II/,N-Queens II,Backtracking,"['class Solution:\n    def totalNQueens(self, n: int) -> int:\n        def solve(row: int, cols: set[int], diags1: set[int], diags2: set[int]) -> int:\n            # base: if all queens are placed, return 1 (count towards the solution)\n            if row == n:\n                return 1\n            # count the number of solutions\n            count = 0\n            \n            for col in range(n):\n                # count the diagonals\n                d1 = row - col  # diagonal\n                d2 = row + col  # anti-diagonal\n                \n                # Check if the column or diagonals are not under attack\n                if col in cols or d1 in diags1 or d2 in diags2:\n                    # Skip the current column if under attack\n                    continue\n                \n                 # Place the queen by adding the column and diagonal indices to the sets\n                cols.add(col)\n                diags1.add(d1)\n                diags2.add(d2)\n                \n                # Recurse to place the next queen\n                count += solve(row + 1, cols, diags1, diags2)\n                \n                # Backtrack: Remove the queen and clear the attacks from sets\n                cols.remove(col)\n                diags1.remove(d1)\n                diags2.remove(d2)\n                \n            return count\n        \n        return solve(0, set(), set(), set())\n        ', '# Example usage\nsolution = Solution()\n\nres: list[int] = []\n\nfor i in range(1, 10):\n    res.append(solution.totalNQueens(i))\n\nres']"
"Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",Generate well-formed parentheses,"Input: n = 3; Output: [""((()))"",""(()())"",""(())()"",""()(())"",""()()()""]. Input: n = 1; Output: [""()""].",1 <= n <= 8,https://leetcode.com/problems/Generate-Parentheses/,Generate Parentheses,Backtracking,"[""class Solution:\n    def generateParenthesis(self, n: int) -> list[str]:\n        res: list[str] = []\n\n        def backtrack(curr: str, open: int, close: int):\n            # base case: When the length of the string reaches 2n (since each pair contributes two characters),\n            # a valid combination has been formed.\n            if len(curr) == 2 * n:\n                res.append(curr)\n                return\n\n            # If the number of open brackets is less than n, we can add an open bracket.\n            if open < n:\n                backtrack(curr + '(', open + 1, close)\n\n            # If the number of close brackets is less than the number of open brackets, we can add a close bracket.\n            if close < open:\n                backtrack(curr + ')', open, close + 1)\n\n        backtrack('', 0, 0)\n        return res"", '# Testing the function with n = 3 and n = 1\n\ns = Solution()\n\ngenerate_parentheses_3 = s.generateParenthesis(3)\ngenerate_parentheses_1 = s.generateParenthesis(1)\n\ngenerate_parentheses_3, generate_parentheses_1']"
What is the time and space complexity of the algorithm for searching words in an m x n grid?,Time and space complexity analysis,"Input: m = 3, n = 4, word = 'test'; Output: Time complexity O(m * n * 4^l), Space complexity O(l)","Grid size m x n, word length l",https://leetcode.com/problems/Word-Search/,Word Search,Backtracking,"[""class Solution:\n    def exist(self, board: list[list[str]], word: str) -> bool:\n        def dfs(index: int, x: int, y: int) -> bool:\n            # Base case: If the index is equal to the length of the word, then we have found the word\n            if index == len(word):\n                return True\n            \n            # If the current cell is out of bounds or does not match the current character, return False\n            if x < 0 or x >= len(board) or y < 0 or y >= len(board[0]):\n                return False\n            \n            # If the current cell does not match the current character, return False\n            if board[x][y] != word[index]:\n                return False\n            \n            # Store the current character in a temporary variable\n            temp = board[x][y]\n            \n            # Mark the current cell as visited\n            board[x][y] = ''\n            \n            # Recursively search for the next character in the word in the adjacent cells\n            for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                if dfs(index + 1, x + dx, y + dy):\n                    return True\n                \n            # Restore the current cell to its original value\n            board[x][y] = temp\n            \n            # If the word is not found, return False\n            return False\n        \n        # Iterate through the board and search for the first character of the word\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                # Start the search from each cell that matches the first letter of the word\n                if board[i][j] == word[0]:\n                    if dfs(0, i, j):\n                        return True\n                    \n        # If the word is not found, return False\n        return False"", 's = Solution()\n\ntest_boards = [\n    ([[""A"", ""B"", ""C"", ""E""], [""S"", ""F"", ""C"", ""S""], [""A"", ""D"", ""E"", ""E""]], ""ABCCED""),\n    ([[""A"", ""B"", ""C"", ""E""], [""S"", ""F"", ""C"", ""S""], [""A"", ""D"", ""E"", ""E""]], ""ABCB""),\n    ([[""A"", ""B"", ""C"", ""E""], [""S"", ""F"", ""C"", ""S""], [""A"", ""D"", ""E"", ""E""]], ""SEE""),\n    ([[""A"", ""B"", ""C"", ""E""], [""S"", ""F"", ""C"", ""S""], [""A"", ""D"", ""E"", ""E""]], ""XYZ""),\n    ([[""A"", ""B"", ""C"", ""E""], [""S"", ""F"", ""E"", ""S""], [""A"", ""D"", ""E"", ""E""]], ""ABCESEEEFS""),\n    ([[""A"", ""B"", ""C""], [""D"", ""E"", ""F""], [""G"", ""H"", ""I""]], ""G""),\n    ([[""A"", ""B"", ""C""], [""D"", ""E"", ""F""], [""G"", ""H"", ""I""]], ""Z""),\n    ([[""A"", ""B""], [""C"", ""D""]], ""ABCD""),\n]\n\n# Running the test cases\nfor board, word in test_boards:\n    print(f""Testing word \'{word}\' in board: Result is {s.exist(board, word)}"")']"
"Given an integer array `nums` sorted in ascending order, convert it to a height-balanced binary search tree.",Convert sorted array to BST,"Input: nums = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5]",1 <= nums.length <= 104; -104 <= nums[i] <= 104; nums is sorted in strictly increasing order.,https://leetcode.com/problems/Convert-Sorted-Array-to-Sorted-Binary-Search-Tree/,Convert Sorted Array to Sorted Binary Search Tree,Divide and Conquer,"['from __future__ import annotations\nfrom typing import Optional\nfrom collections import deque', 'class TreeNode:\n    def __init__(\n        self,\n        val: Optional[int] = 0,\n        left: Optional[""TreeNode""] = None,\n        right: Optional[""TreeNode""] = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @staticmethod\n    def from_list(values: list[Optional[int]]) -> Optional[""TreeNode""]:\n        if not values:\n            return None\n\n        root = TreeNode(val=values[0])\n        queue: deque[TreeNode] = deque([root])\n        i = 1\n\n        while queue and i < len(values):\n            current_node = queue.popleft()\n\n            if values[i] is not None:\n                current_node.left = TreeNode(val=values[i])\n                queue.append(current_node.left)\n            i += 1\n\n            if i < len(values) and values[i] is not None:\n                current_node.right = TreeNode(val=values[i])\n                queue.append(current_node.right)\n            i += 1\n\n        return root\n\n    def print_level_order(self) -> list[list[Optional[int]]]:\n        queue: deque[tuple[TreeNode, int]] = deque([(self, 0)])\n        result = []\n        current_level = []\n        level_number = 0\n\n        while queue:\n            current_node, node_level = queue.popleft()\n\n            if node_level > level_number:\n                result.append(current_level)\n                current_level = []\n                level_number = node_level\n\n            current_level.append(current_node.val)\n            if current_node.left is not None:\n                queue.append((current_node.left, node_level + 1))\n            if current_node.right is not None:\n                queue.append((current_node.right, node_level + 1))\n\n        if current_level:\n            result.append(current_level)\n\n        return result\n    \n    def inorder_traversal(self) -> list[int]:\n        result = []\n        stack = []\n        current = self\n\n        while current or stack:\n            while current:\n                stack.append(current)\n                current = current.left\n\n            current = stack.pop()\n            result.append(current.val)\n            current = current.right\n\n        return result', 'class Solution:\n    def sortedArrayToBST(self, nums: list[int]) -> Optional[TreeNode]:\n        if not nums:\n            return None\n\n        mid = len(nums) // 2\n\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid + 1:])\n\n        return root', 's = Solution()\n\nnums1 = [-10, -3, 0, 5, 9]\nnums2 = [1, 3]\n\nroot1 = s.sortedArrayToBST(nums1)\nroot2 = s.sortedArrayToBST(nums2)\n\nprint(""Example 1 Output:"", root1.inorder_traversal() if root1 else None)\nprint(""Example 2 Output:"", root2.inorder_traversal() if root2 else None)']"
What is the time and space complexity of the merge sort algorithm on a linked list?,Merge sort complexity analysis,"Input: Linked list of n nodes; Output: Time complexity O(n log n), Space complexity O(1) or O(log n)",n is the number of nodes in the linked list,https://leetcode.com/problems/Sort-List/,Sort List,Divide and Conquer,"['from __future__ import annotations\nfrom typing import Optional', '# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val: int = 0, next: Optional[ListNode] = None):\n        self.val = val\n        self.next = next\n\n    @staticmethod\n    def from_list(l: list[int]) -> ListNode | None:\n        if not l:  # Check if the list is empty\n            return None  # Return None if the list is empty\n        head = ListNode(l[0])\n        current = head\n        for i in l[1:]:\n            current.next = ListNode(i)\n            current = current.next\n        return head\n\n    def to_list(self) -> list[int]:\n        l = [self.val]\n        current = self\n        while current.next:\n            current = current.next\n            l.append(current.val)\n        return l\n\n    def print(self) -> None:\n        print(self.to_list())', 'class Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n\n        # split the list into two halves\n        prev, slow, fast = None, head, head\n\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        # cut the list into two halves by setting the previous node of the first half to None\n        prev.next = None\n\n        # sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(slow)\n\n        return self.merge(left, right)\n\n    def merge(\n        self, left: Optional[ListNode], right: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        dummy = ListNode()\n        current = dummy\n\n        while left and right:\n            if left.val < right.val:\n                current.next = left\n                left = left.next\n            else:\n                current.next = right\n                right = right.next\n            current = current.next\n\n        current.next = left or right\n\n        return dummy.next', '# Test cases\ns = Solution()\n\nhead = ListNode.from_list([4, 2, 1, 3])\nsorted_head = s.sortList(head)\nprint(sorted_head.to_list() if sorted_head else [])  # Output: [1, 2, 3, 4]\n\nhead = ListNode.from_list([-1, 5, 3, 4, 0])\nsorted_head = s.sortList(head)\nprint(sorted_head.to_list() if sorted_head else [])  # Output: [-1, 0, 3, 4, 5]\n\nhead = ListNode.from_list([])\nsorted_head = s.sortList(head)\nprint(sorted_head.to_list() if sorted_head else [])  # Output: []']"
"Given a n * n matrix grid of 0's and 1's, return the root of the Quad-Tree representing grid.",Construct Quad Tree from grid,"Input: grid = [[0,1],[1,0]]; Output: [[0,1],[1,0],[1,1],[1,1],[1,0]]",n == grid.length == grid[i].length; n == 2^x where 0 <= x <= 6,https://leetcode.com/problems/Construct-Quad-Tree/,Construct Quad Tree,Divide and Conquer,"['class Node:\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight', 'class Solution:\n    def construct(self, grid: list[list[int]]) -> ""Node"":\n        def build_tree(x, y, size):\n            if size == 1:\n                return Node(grid[x][y] == 1, True, None, None, None, None)\n            half = size // 2\n            topLeft = build_tree(x, y, half)\n            topRight = build_tree(x, y + half, half)\n            bottomLeft = build_tree(x + half, y, half)\n            bottomRight = build_tree(x + half, y + half, half)\n            \n            if (\n                topLeft.isLeaf\n                and topRight.isLeaf\n                and bottomLeft.isLeaf\n                and bottomRight.isLeaf\n                and topLeft.val == topRight.val == bottomLeft.val == bottomRight.val\n            ):\n                return Node(topLeft.val, True, None, None, None, None)\n            \n            return Node(True, False, topLeft, topRight, bottomLeft, bottomRight)\n        \n        return build_tree(0, 0, len(grid))', 'def serialize(node):\n    """"""Serialize the quad-tree into a list format for easier visualization.""""""\n    if not node:\n        return [""null""]\n    if node.isLeaf:\n        return [[1 if node.isLeaf else 0, 1 if node.val else 0]]\n    result = [[1 if node.isLeaf else 0, 1 if node.val else 0]]\n    children = (\n        serialize(node.topLeft)\n        + serialize(node.topRight)\n        + serialize(node.bottomLeft)\n        + serialize(node.bottomRight)\n    )\n    result.extend(children)\n    return result\n\n\ndef print_tree(node):\n    """"""Print the serialized quad-tree.""""""\n    serialized = serialize(node)\n    print(serialized)', '# Use the same tree from earlier example to print results\n\ns = Solution()\n\ngrid = [[1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0]]\ntree = s.construct(grid)\nprint_tree(tree)']"
What are the time and space complexities of merging k sorted linked lists using a min-heap?,Complexity of merging k lists,Input: k sorted linked lists; Output: Merged sorted linked list,"k is the number of linked lists, n is the total number of elements across all lists.",https://leetcode.com/problems/Merge-K-Sorted-Lists/,Merge K Sorted Lists,Divide and Conquer,"['from __future__ import annotations\nfrom typing import Optional', '# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val: int = 0, next: Optional[ListNode] = None):\n        self.val = val\n        self.next = next\n\n    @staticmethod\n    def from_list(l: list[int]) -> ListNode | None:\n        if not l:  # Check if the list is empty\n            return None  # Return None if the list is empty\n        head = ListNode(l[0])\n        current = head\n        for i in l[1:]:\n            current.next = ListNode(i)\n            current = current.next\n        return head\n\n    def to_list(self) -> list[int]:\n        l = [self.val]\n        current = self\n        while current.next:\n            current = current.next\n            l.append(current.val)\n        return l\n\n    def print(self) -> None:\n        print(self.to_list())', 'from heapq import heappop, heappush\n\n\nclass Solution:\n    def mergeKLists(self, lists: list[Optional[ListNode]]) -> Optional[ListNode]:\n        #  Initialize a heap\n        heap = []\n\n        for index, node in enumerate(lists):\n            if node:\n                heappush(heap, (node.val, index, node))\n\n        # Initialize a dummy node\n        dummy = ListNode(None)\n        current = dummy\n\n        while heap:\n            val, index, node = heappop(heap)\n            # Add the smallest element to the merged list\n            current.next = ListNode(val)\n            current = current.next\n\n            if node.next:\n                # Move to the next node in the list\n                heappush(heap, (node.next.val, index, node.next))\n\n        return dummy.next', '# Test case\nl1 = ListNode.from_list([1, 4, 5])\nl2 = ListNode.from_list([1, 3, 4])\nl3 = ListNode.from_list([2, 6])\nsol = Solution()\n\nsol.mergeKLists([l1, l2, l3]).print()  # [1, 1, 2, 3, 4, 4, 5, 6]']"
"Given an integer array nums, find the subarray with the largest sum, and return its sum.",Find maximum subarray sum,"Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6; Input: nums = [1] Output: 1; Input: nums = [5,4,-1,7,8] Output: 23",1 <= nums.length <= 10^5; -10^4 <= nums[i] <= 10^4,https://leetcode.com/problems/Maximum-Subarray/,Maximum Subarray,Kadane’s Algorithm,"['class Solution:\n    def maxSubArray(self, nums: list[int]) -> int:\n        local_max = 0\n        global_max = -float(""inf"")\n\n        for num in nums:\n            local_max = max(num, num + local_max)\n            global_max = max(local_max, global_max)\n\n        return global_max', '# Test case\ns = Solution()\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(s.maxSubArray(nums))  # Output: 6', ""def maxSubArray(nums):\n    def maxCrossingSum(nums, left, mid, right):\n        # Include at least one element from left half\n        sum_left = float('-inf')\n        current_sum = 0\n        for i in range(mid, left - 1, -1):\n            current_sum += nums[i]\n            if current_sum > sum_left:\n                sum_left = current_sum\n\n        # Include at least one element from right half\n        sum_right = float('-inf')\n        current_sum = 0\n        for i in range(mid + 1, right + 1):\n            current_sum += nums[i]\n            if current_sum > sum_right:\n                sum_right = current_sum\n\n        # Return sum of elements on left and right of mid\n        # as it's the maximum sum of subarray crossing mid\n        return sum_left + sum_right\n\n    def maxSubArrayRec(nums, left, right):\n        if left == right:  # Base case: only one element\n            return nums[left]\n\n        mid = (left + right) // 2\n        left_max = maxSubArrayRec(nums, left, mid)\n        right_max = maxSubArrayRec(nums, mid + 1, right)\n        cross_max = maxCrossingSum(nums, left, mid, right)\n\n        return max(left_max, right_max, cross_max)\n\n    return maxSubArrayRec(nums, 0, len(nums) - 1)\n\n\n# Example usage:\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArray(nums))  # Output: 6""]"
"Given a circular integer array `nums`, return the maximum possible sum of a non-empty subarray of `nums`.",Maximum sum circular subarray,"Input: nums = [1,-2,3,-2], Output: 3; Input: nums = [5,-3,5], Output: 10; Input: nums = [-3,-2,-3], Output: -2.",1 <= n <= 3 * 10^4; -3 * 10^4 <= nums[i] <= 3 * 10^4.,https://leetcode.com/problems/Maximum-Sum-Circular-Subarray/,Maximum Sum Circular Subarray,Kadane’s Algorithm,"[""class Solution:\n    def maxSubarraySumCircular(self, nums: list[int]) -> int:\n        def kadane(nums: list[int]) -> int:\n            max_sum = float('-inf')\n            current_sum = 0\n            for num in nums:\n                current_sum = max(num, current_sum + num)\n                max_sum = max(max_sum, current_sum)\n            return max_sum\n        \n        # step 1: find the max sum of non-circular subarray\n        max_kadane = kadane(nums)\n        \n        # step 2: find the total sum of the array and the min sum of non-circular subarray\n        total_sum = sum(nums)\n        \n        # invert the sign of each element in the array\n        nums_inverted = [-num for num in nums]\n        max_kadane_inverted = kadane(nums_inverted)\n        min_subarray_sum = -max_kadane_inverted\n        \n        # step 3: find the max sum of circular subarray\n        max_circular = total_sum - min_subarray_sum\n        \n        # step 4: handle the edge case\n        if max_circular == 0:\n            return max_kadane\n        \n        return max(max_kadane, max_circular)"", 's = Solution()\n\nprint(s.maxSubarraySumCircular([1, -2, 3, -2]))  # Output: 3\nprint(s.maxSubarraySumCircular([5, -3, 5]))      # Output: 10\nprint(s.maxSubarraySumCircular([-3, -2, -3]))    # Output: -2']"
"Given a sorted array of distinct integers and a target value, return the index if the target is found, or the index where it would be inserted in order, with O(log n) runtime complexity.",Search insert position,"Input: nums = [1,3,5,6], target = 5; Output: 2. Input: nums = [1,3,5,6], target = 2; Output: 1. Input: nums = [1,3,5,6], target = 7; Output: 4.",1 <= nums.length <= 10^4; -10^4 <= nums[i] <= 10^4; nums contains distinct values sorted in ascending order; -10^4 <= target <= 10^4.,https://leetcode.com/problems/Search-Insert-Position/,Search Insert Position,Binary Search,"['class Solution:\n    def searchInsert(self, nums: list[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n\n            if nums[mid] == target:\n                return mid\n\n            if nums[mid] < target:\n                left = mid + 1\n\n            else:\n                right = mid - 1\n\n        return left', '# Test cases\n\ns = Solution()\n\nprint(s.searchInsert([1, 3, 5, 6], 5))  # Output: 2\nprint(s.searchInsert([1, 3, 5, 6], 2))  # Output: 1\nprint(s.searchInsert([1, 3, 5, 6], 7))  # Output: 4']"
"Given an m x n integer matrix with sorted rows and specific properties, determine if a target integer exists in the matrix, achieving O(log(m * n)) time complexity.",Search in 2D matrix,"Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3; Output: true. Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13; Output: false.","1 <= m, n <= 100; -10^4 <= matrix[i][j], target <= 10^4.",https://leetcode.com/problems/Search-a-2D-Matrix/,Search a 2D Matrix,Binary Search,"['class Solution:\n    def searchMatrix(self, matrix: list[list[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            mid_value = matrix[mid // n][mid % n]\n\n            if mid_value == target:\n                return True\n            elif mid_value < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return False', '# Test cases\ns = Solution()\n\nmatrix1 = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]\ntarget1 = 3\nprint(s.searchMatrix(matrix1, target1))  # Output: true\n\nmatrix2 = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]\ntarget2 = 13\nprint(s.searchMatrix(matrix2, target2))  # Output: false']"
"Given a 0-indexed integer array nums, find a peak element and return its index. A peak element is strictly greater than its neighbors. The algorithm must run in O(log n) time.",Find peak element index,"Input: nums = [1,2,3,1] Output: 2; Input: nums = [1,2,1,3,5,6,4] Output: 5",1 <= nums.length <= 1000; -2^31 <= nums[i] <= 2^31 - 1; nums[i] != nums[i + 1] for all valid i.,https://leetcode.com/problems/Find-Peak-Element/,Find Peak Element,Binary Search,"['class Solution:\n    def findPeakElement(self, nums: list[int]) -> int:\n        left, right = 0, len(nums) - 1\n\n        while left < right:\n            mid = (left + right) // 2\n\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left', '# Test\ns = Solution()\n\n# Example 1\nnums1 = [1, 2, 3, 1]\nprint(s.findPeakElement(nums1))  # Output: 2\n\n# Example 2\nnums2 = [1, 2, 1, 3, 5, 6, 4]\nprint(s.findPeakElement(nums2))  # Output: 5']"
"Given a rotated sorted array and a target, find the index of the target or return -1 if not found.",Search in Rotated Array,"Input: nums = [4,5,6,7,0,1,2], target = 0; Output: 4. Input: nums = [4,5,6,7,0,1,2], target = 3; Output: -1. Input: nums = [1], target = 0; Output: -1.","1 <= nums.length <= 5000, -10^4 <= nums[i] <= 10^4, All values of nums are unique, -10^4 <= target <= 10^4.",https://leetcode.com/problems/Search-in-Rotated-Sorted-Array/,Search in Rotated Sorted Array,Binary Search,"['class Solution:\n    def search(self, nums: list[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n\n            if nums[mid] == target:\n                return mid\n\n            # decide which part is sorted\n            if nums[left] <= nums[mid]:\n                # left part is sorted\n                if nums[left] <= target <= nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                # right part is sorted\n                if nums[mid] <= target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n\n        return -1', '# Test cases\n\ns = Solution()\n\nprint(s.search([4, 5, 6, 7, 0, 1, 2], 0))  # Output: 4\nprint(s.search([4, 5, 6, 7, 0, 1, 2], 3))  # Output: -1\nprint(s.search([1], 0))                    # Output: -1']"
"Given a sorted array of integers, find the starting and ending position of a target value. If the target is not found, return [-1, -1]. The algorithm must have O(log n) runtime complexity.",Find target positions in array,"Input: nums = [5,7,7,8,8,10], target = 8; Output: [3,4]. Input: nums = [5,7,7,8,8,10], target = 6; Output: [-1,-1]. Input: nums = [], target = 0; Output: [-1,-1].",0 <= nums.length <= 10^5; -10^9 <= nums[i] <= 10^9; nums is a non-decreasing array; -10^9 <= target <= 10^9.,https://leetcode.com/problems/Find-First-and-Last-Position-of-Element-in-Sorted-Array/,Find First and Last Position of Element in Sorted Array,Binary Search,"['class Solution:\n    def searchRange(self, nums: list[int], target: int) -> list[int]:\n        def find_left_most(nums: list[int], target: int) -> int:\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = left + (right - left) // 2\n                if nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return left\n        \n        def find_right_most(nums: list[int], target: int) -> int:\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = left + (right - left) // 2\n                # the condition ensures even if nums[mid] == target, \n                # we still move right to find the last occurrence\n                if nums[mid] <= target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return right\n        \n        left_most = find_left_most(nums, target)\n        right_most = find_right_most(nums, target)\n        \n        # Check if the target is actually in the array\n        if left_most <= right_most and 0 <= left_most < len(nums) and nums[left_most] == target:\n            return [left_most, right_most]\n        else:\n            return [-1, -1]', '# Test cases\ns = Solution()\n\nprint(s.searchRange([5, 7, 7, 8, 8, 10], 8))  # Output: [3, 4]\nprint(s.searchRange([5, 7, 7, 8, 8, 10], 6))  # Output: [-1, -1]\nprint(s.searchRange([], 0))  # Output: [-1, -1]']"
"Given a sorted rotated array of unique elements, return the minimum element of this array. The algorithm must run in O(log n) time.",Find minimum in rotated array,"Input: nums = [3,4,5,1,2] Output: 1; Input: nums = [4,5,6,7,0,1,2] Output: 0; Input: nums = [11,13,15,17] Output: 11",1 <= n <= 5000; -5000 <= nums[i] <= 5000; All integers in nums are unique; nums is sorted and rotated between 1 and n times.,https://leetcode.com/problems/Find-Minimum-in-Rotated-Sorted-Array/,Find Minimum in Rotated Sorted Array,Binary Search,"['class Solution:\n    def findMin(self, nums: list[int]) -> int:\n        left, right = 0, len(nums) - 1\n\n        while left < right:\n            mid = (left + right) // 2\n\n            # if mid element is greater than right element, then the minimum element is in the right half\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            # else the minimum element is in the left half\n            else:\n                right = mid\n\n        # when the loop ends, left == right, so return the element at that index\n        return nums[left]', '# Examples\ns = Solution()\n\nprint(s.findMin([3, 4, 5, 1, 2]))  # Output: 1\nprint(s.findMin([4, 5, 6, 7, 0, 1, 2]))  # Output: 0\nprint(s.findMin([11, 13, 15, 17]))  # Output: 11']"
How to find the median of two sorted arrays with optimal runtime complexity of O(log(m+n)) using binary search?,Median of two sorted arrays,"Input: nums1 = [1, 3], nums2 = [2]; Output: 2.0",Both arrays are sorted and may be of different lengths.,https://leetcode.com/problems/Median-of-Two-Sorted-Arrays/,Median of Two Sorted Arrays,Binary Search,"[""class Solution:\n    def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -> float:\n        # ensure nums1 is the shorter list to minimize binaray search range\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n            \n        # get the length of two lists\n        m, n = len(nums1), len(nums2)\n        total = m + n\n        half = (total + 1) // 2\n        \n        # set the range of binary search\n        left, right = 0, m\n        \n        # binary search\n        while left <= right:\n            i = (left + right) // 2\n            j = half - i\n            \n            # handle the boundary conditions of i and j\n            left_max1 = float('-inf') if i == 0 else nums1[i - 1]\n            right_min1 = float('inf') if i == m else nums1[i]\n            left_max2 = float('-inf') if j == 0 else nums2[j - 1]\n            right_min2 = float('inf') if j == n else nums2[j]\n            \n            # binary search adjustment\n            if left_max1 > right_min2:\n                right = i - 1\n            elif left_max2 > right_min1:\n                left = i + 1\n            else:\n                # found the correct partition\n                if total % 2 == 0:\n                    return float((max(left_max1, left_max2) + min(right_min1, right_min2)) / 2)\n                else:\n                    return float(max(left_max1, left_max2))\n                \n        return -1.0"", '# Example usage:\ns = Solution()\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(""Median:"", s.findMedianSortedArrays(nums1, nums2))  # Output: 2.0\n\nnums1 = [1, 2]\nnums2 = [3, 4]\nprint(""Median:"", s.findMedianSortedArrays(nums1, nums2))  # Output: 2.5']"
"Given an integer array `nums` and an integer `k`, return the `kth` largest element in the array without sorting.",Kth largest element in array,"Input: nums = [3,2,1,5,6,4], k = 2; Output: 5. Input: nums = [3,2,3,1,2,4,5,5,6], k = 4; Output: 4.",1 <= k <= nums.length <= 10^5; -10^4 <= nums[i] <= 10^4,https://leetcode.com/problems/Kth-Largest-Element-in-an-Array/,Kth Largest Element in an Array,Heap,"['from heapq import heappush, heapreplace\n\n\nclass Solution:\n    def findKthLargest(self, nums: list[int], k: int) -> int:\n        # create an empty min-heap\n        min_heap = []\n\n        # iterate through the list of numbers\n        for num in nums:\n            if len(min_heap) < k:\n                heappush(min_heap, num)\n            else:\n                # only push the number if it is greater than the smallest number in the heap\n                if num > min_heap[0]:\n                    heapreplace(min_heap, num)\n\n        # the kth largest number is the smallest number in the heap (root)\n        return min_heap[0]', '# Example usage:\n\ns = Solution()\n\nnums1 = [3, 2, 1, 5, 6, 4]\nk1 = 2\nprint(s.findKthLargest(nums1, k1))  # Output: 5\n\nnums2 = [3, 2, 3, 1, 2, 4, 5, 5, 6]\nk2 = 4\nprint(s.findKthLargest(nums2, k2))  # Output: 4']"
"LeetCode wants to maximize its total capital by completing at most k distinct projects, given initial capital and project requirements.",Maximize capital from projects,"Input: k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]; Output: 4","1 <= k <= 10^5, 0 <= w <= 10^9, n == profits.length, n == capital.length, 1 <= n <= 10^5, 0 <= profits[i] <= 10^4, 0 <= capital[i] <= 10^9",https://leetcode.com/problems/IPO/,IPO,Heap,"['import heapq\n\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: list[int], capital: list[int]) -> int:\n        # Create a min-heap for capital requirements\n        min_capital_heap = []\n        # Create a max-heap for profits\n        max_profit_heap = []\n\n        # Insert all projects into the min-heap based on capital\n        for i in range(len(profits)):\n            heapq.heappush(min_capital_heap, (capital[i], profits[i]))\n\n        # Iterate up to k times or until no projects can be done\n        for _ in range(k):\n            # Move all projects that can be started with current capital to max-heap\n            while min_capital_heap and min_capital_heap[0][0] <= w:\n                cap, prof = heapq.heappop(min_capital_heap)\n                # Use negative profits to simulate max-heap with min-heap\n                heapq.heappush(max_profit_heap, -prof)\n\n            # If no projects can be done, break the loop\n            if not max_profit_heap:\n                break\n\n            # Choose the project with the maximum profit\n            w -= heapq.heappop(max_profit_heap)\n\n        return w\n\n\n# Example usage:\ns = Solution()\n\nk = 2\nw = 0\nprofits = [1, 2, 3]\ncapital = [0, 1, 1]\nprint(s.findMaximizedCapital(k, w, profits, capital))  # Output: 4\n\nk = 3\nw = 0\nprofits = [1, 2, 3]\ncapital = [0, 1, 2]\nprint(s.findMaximizedCapital(k, w, profits, capital))  # Output: 6']"
"Given two sorted integer arrays nums1 and nums2, return the k pairs with the smallest sums.",Find K smallest sum pairs,"Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3; Output: [[1,2],[1,4],[1,6]]","1 <= nums1.length, nums2.length <= 10^5; -10^9 <= nums1[i], nums2[i] <= 10^9; nums1 and nums2 are sorted; 1 <= k <= 10^4; k <= nums1.length * nums2.length",https://leetcode.com/problems/Find-K-Pairs-with-Smallest-Sums/,Find K Pairs with Smallest Sums,Heap,"['import heapq as hq\n\n\nclass Solution:\n    def kSmallestPairs(self, nums1: list[int], nums2: list[int], k: int) -> list[list[int]]:\n        if not nums1 or not nums2:\n            return []\n\n        # Create a min-heap to store the pairs along with their sum\n        # (sum, index in nums1, index in nums2)\n        min_heap = []\n\n        # Start by pairing the all element in nums1 with smallest elements in nums2\n        for i in range(min(k, len(nums1))):\n            hq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))\n\n        result = []\n\n        # Keep popping the smallest pair from the heap and add it to the result\n        # Then add the next pair from nums2 to the heap\n        while min_heap and len(result) < k:\n            _, i, j = hq.heappop(min_heap)\n            result.append([nums1[i], nums2[j]])\n            if j + 1 < len(nums2):\n                hq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\n        return result', '# Test cases\n\ns = Solution()\n\n# Test 1\nnums1 = [1, 7, 11]\nnums2 = [2, 4, 6]\nk = 3\n# Expected: [[1, 2], [1, 4], [1, 6]]\nprint(s.kSmallestPairs(nums1, nums2, k))\n\n# Test 2\nnums1 = [1, 1, 2]\nnums2 = [1, 2, 3]\nk = 2\n# Expected: [[1, 1], [1, 1]]\nprint(s.kSmallestPairs(nums1, nums2, k))']"
How can we efficiently compute the median for a data stream with specific number ranges?,Optimizations for median calculation,"Input: [1, 2, 3, 4, 5]; Output: 3","Numbers are primarily in the range [0, 100]",https://leetcode.com/problems/Find-Median-from-Data-Stream/,Find Median from Data Stream,Heap,"['import heapq as hq\n\n\nclass MedianFinder:\n\n    def __init__(self):\n        # max heap stores the smaller half of the numbers. Root of the heap is the largest number in the lower half\n        self.lower_half = []  # max heap (negated)\n        # min heap stores the larger half of the numbers. Root of the heap is the smallest number in the upper half\n        self.upper_half = []  # min heap\n\n    # Time complexity: O(log n)\n    def addNum(self, num: int) -> None:\n        hq.heappush(self.lower_half, -num)  # add to lower half\n\n        # balance the heaps\n        # the max heap can have at most 1 more element than the min heap\n        # if the total number of elements is odd, the max heap will have 1 more element than the min heap\n\n        if (\n            self.lower_half\n            and self.upper_half\n            and -self.lower_half[0] > self.upper_half[0]\n        ):\n            # if the max heap has more elements than the min heap, move the root of the max heap to the min heap\n            hq.heappush(self.upper_half, -hq.heappop(self.lower_half))\n\n        # ensure that the max heap have at most 1 more element than the min heap\n        if len(self.lower_half) > len(self.upper_half) + 1:\n            hq.heappush(self.upper_half, -hq.heappop(self.lower_half))\n\n        # ensure min heap has less elements than the max heap\n        if len(self.upper_half) > len(self.lower_half):\n            hq.heappush(self.lower_half, -hq.heappop(self.upper_half))\n\n    # Time complexity: O(1)\n    def findMedian(self) -> float:\n        if len(self.lower_half) > len(self.upper_half):\n            return float(-self.lower_half[0])\n        return float((-self.lower_half[0] + self.upper_half[0]) / 2.0)', '# Example usage\nmedianFinder = MedianFinder()\nmedianFinder.addNum(1)\nmedianFinder.addNum(2)\nprint(medianFinder.findMedian())  # Output: 1.5\nmedianFinder.addNum(3)\nprint(medianFinder.findMedian())  # Output: 2.0', 'class MedianFinderRange:\n    def __init__(self):\n        self.counts = [0] * 101\n        self.total_count = 0\n\n    def addNum(self, num: int) -> None:\n        self.counts[num] += 1\n        self.total_count += 1\n\n    def findMedian(self) -> float:\n        count = 0\n        median1 = None\n        median2 = None\n        for i in range(101):\n            count += self.counts[i]\n            if median1 is None and count >= (self.total_count + 1) // 2:\n                median1 = i\n            if median2 is None and count >= (self.total_count // 2) + 1:\n                median2 = i\n                break\n        if self.total_count % 2 == 0 and median1 is not None and median2 is not None:\n            return (median1 + median2) / 2.0\n        elif median2 is not None:\n            return median2\n\n        return 0.0\n\n\n# Example usage\nmedianFinder = MedianFinderRange()\nmedianFinder.addNum(1)\nmedianFinder.addNum(2)\nprint(medianFinder.findMedian())  # Output: 1.5\nmedianFinder.addNum(3)\nprint(medianFinder.findMedian())  # Output: 2.0']"
"Given two binary strings `a` and `b`, return their sum as a binary string.",Add two binary strings,"Input: a = ""11"", b = ""1""; Output: ""100"". Input: a = ""1010"", b = ""1011""; Output: ""10101"".","1 <= a.length, b.length <= 104; a and b consist only of '0' or '1' characters; Each string does not contain leading zeros except for the zero itself.",https://leetcode.com/problems/Add-Binary/,Add Binary,Bit Manipulation,"[""class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        result = []\n        carry = 0\n\n        # pointer for a and b\n        i, j = len(a) - 1, len(b) - 1\n\n        while i >= 0 or j >= 0 or carry:\n            # Convert char to int if index is valid, else take 0\n            bit_a = int(a[i]) if i >= 0 else 0\n            bit_b = int(b[j]) if j >= 0 else 0\n\n            # Calculate the sum and carry\n            total = bit_a + bit_b + carry\n            result.append(str(total % 2))  # Append the remainder (0 or 1)\n            carry = total // 2  # Update the carry\n\n            # Move to the next digits\n            i -= 1\n            j -= 1\n\n        # The result is in reverse order\n        return ''.join(reversed(result))"", '# Example usage\ns = Solution()\n\na = ""11""\nb = ""1""\nprint(s.addBinary(a, b))  # Output: ""100""\n\na = ""1010""\nb = ""1011""\nprint(s.addBinary(a, b))  # Output: ""10101""']"
How can I optimize a frequently called function using memoization in Python?,Optimize function with caching,"Input: function_call(5), Output: 25; Input: function_call(5), Output: 25 (cached)",Function must be called with the same values frequently.,https://leetcode.com/problems/Reverse-Bit/,Reverse Bit,Bit Manipulation,"['class Solution:\n    def reverseBits(self, n: int) -> int:\n        # Initialize result as 0\n        result = 0\n        \n        # Iterate through all 32 bits of the integer\n        for _ in range(32):\n            # Shift result to the left to make room for the next bit\n            result <<= 1\n            \n            # Add the least significant bit of n to result\n            result |= n & 1\n            \n            # Shift n to the right to process the next bit\n            n >>= 1\n        \n        return result', '# Example usage:\ns = Solution()\n\ninput1 = 0b00000010100101000001111010011100\noutput1 = s.reverseBits(input1)\nprint(f""Reversed bits: {output1} ({bin(output1)})"")\n\ninput2 = 0b11111111111111111111111111111101\noutput2 = s.reverseBits(input2)\nprint(f""Reversed bits: {output2} ({bin(output2)})"")', 'from functools import lru_cache\n\n@lru_cache(None)\ndef reverse_bits(n):\n    result = 0\n    for _ in range(32):\n        result = (result << 1) | (n & 1)\n        n >>= 1\n    return result']"
Write a function that takes the binary representation of a positive integer and returns the number of set bits it has (Hamming weight).,Count set bits in integer,"Input: n = 11, Output: 3; Input: n = 128, Output: 1; Input: n = 2147483645, Output: 30",1 <= n <= 2^31 - 1,https://leetcode.com/problems/Number-of-1-Bits/,Number of 1 Bits,Bit Manipulation,"[""class Solution:\n    def hammingWeight(self, n: int) -> int:\n        return bin(n).count('1')\n\n    def hamming_weight(self, n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1  # Adds 1 to count if the least significant bit is 1\n            n >>= 1  # Shifts bits to the right by 1, effectively dividing n by 2\n        return count"", 's = Solution()\n\nn = 2147483645\nprint(s.hammingWeight(n))  # 30\nprint(s.hamming_weight(n))  # 30']"
What are the key properties of the XOR operation?,Understanding XOR properties,"Input: x = 5, y = 5; Output: x ⊕ y = 0",None,https://leetcode.com/problems/Single-Number/,Single Number,Bit Manipulation,"['class Solution:\n    def singleNumber(self, nums: list[int]) -> int:\n        result = 0\n        for num in nums:\n            result ^= num\n        return result', '# Example usage:\ns = Solution()\n\nprint(s.singleNumber([2, 2, 1]))  # Output: 1\nprint(s.singleNumber([4, 1, 2, 1, 2]))  # Output: 4\nprint(s.singleNumber([1]))  # Output: 1']"
"Given an integer array nums where every element appears three times except for one, which appears exactly once, find the single element and return it. You must implement a solution with a linear runtime complexity and use only constant extra space.",Find single number in array,"Input: nums = [2,2,3,2] Output: 3; Input: nums = [0,1,0,1,0,1,99] Output: 99",1 <= nums.length <= 3 * 10^4; -2^31 <= nums[i] <= 2^31 - 1; Each element in nums appears exactly three times except for one element which appears once.,https://leetcode.com/problems/Single-Number-II/,Single Number II,Bit Manipulation,"['class Solution:\n    def singleNumber(self, nums: list[int]) -> int:\n        ones, twos, threes = 0, 0, 0\n        for num in nums:\n            # Update `twos` by adding bits that have appeared twice\n            twos |= ones & num\n            # Update `ones` by adding current number\n            ones ^= num\n            # `threes` gets bits that have appeared three times\n            threes = ones & twos\n            # Remove bits that have appeared three times from `ones` and `twos`\n            ones &= ~threes\n            twos &= ~threes\n        # The single element is stored in `ones` because it appears exactly once\n        return ones', '# Examples\ns = Solution()\n\n# Example 1\nassert s.singleNumber([2, 2, 3, 2]) == 3\n\n# Example 2\nassert s.singleNumber([0, 1, 0, 1, 0, 1, 99]) == 99']"
"Given two integers left and right, find the common prefix of their binary representations. The common prefix is defined as the longest sequence of bits that are the same in both numbers when represented in binary.",Find common prefix of numbers,"Input: left = 5, right = 7; Output: 4. Input: left = 1, right = 2147483647; Output: 0.",0 <= left <= right <= 2147483647,https://leetcode.com/problems/Bitwise-AND-of-Numbers-Range/,Bitwise AND of Numbers Range,Bit Manipulation,"['class Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        # loop until left is equal to right\n        while left < right:\n            # remove the last bit (leastd significant bit) from right\n            right &= right - 1\n        return right', '# test cases\ns = Solution()\n\nleft = 5\nright = 7\nprint(s.rangeBitwiseAnd(left, right)) # 4']"
How to determine the number of digits in a positive integer n using the formula d = ⌊log₁₀(n)⌋ + 1?,Calculate number of digits,Input: n = 5000; Output: 4,n is a positive integer,https://leetcode.com/problems/Palindrome-Number/,Palindrome Number,Math,"['class Solution:\n    # O(log(n)) time complexity: n has log10(n) digits, so the loop runs log10(n) times, where n is the input number\n    # O(1) space complexity: only a few variables are used\n    def isPalindrome(self, x: int) -> bool:\n        original = x\n        reversed_num = 0\n        while x > 0:\n            digit = x % 10  # Extract the last digit\n            reversed_num = reversed_num * 10 + digit  # Append the digit to the reversed number\n            x = x // 10  # remove the last digit\n        return original == reversed_num', '# Testing\nsol = Solution()\nprint(sol.isPalindrome(121)) # True\nprint(sol.isPalindrome(-121)) # False\nprint(sol.isPalindrome(10)) # False\nprint(sol.isPalindrome(-101)) # False\nprint(sol.isPalindrome(0)) # True']"
You are given a large integer represented as an integer array `digits`. Increment the large integer by one and return the resulting array of digits.,Increment large integer array,"Input: digits = [1,2,3] Output: [1,2,4]; Input: digits = [4,3,2,1] Output: [4,3,2,2]; Input: digits = [9] Output: [1,0]",1 <= digits.length <= 100; 0 <= digits[i] <= 9; digits does not contain any leading 0's.,https://leetcode.com/problems/Plus/,Plus,Math,"['class Solution:\n    # O(n) time complexity: only one pass through the array\n    # O(1) space complexity: no extra space used\n    def plusOne(self, digits: list[int]) -> list[int]:\n        n = len(digits)\n\n        # Traverse the array from the end\n        for i in range(n - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n\n        # If all digits are 9, we need an extra digit at the beginning\n        return [1] + digits', '# examples\ns = Solution()\n\nprint(s.plusOne([1, 2, 3]))  # [1, 2, 4]\nprint(s.plusOne([4, 3, 2, 1]))  # [4, 3, 2, 2]\nprint(s.plusOne([9]))  # [1, 0]']"
How to determine the number of trailing zeroes in the factorial of a given number n?,Count trailing zeroes in factorial,Input: n = 100; Output: 24,n is a non-negative integer.,https://leetcode.com/problems/Factorial-Trailing-Zeroes/,Factorial Trailing Zeroes,Math,"['class Solution:\n    def trailingZeroes(self, n: int) -> int:\n        zeroes = 0\n        power = 5\n        while n >= power:\n            zeroes += n // power\n            power *= 5\n        return zeroes']"
How to find the square root of a non-negative integer x rounded down to the nearest integer using binary search without built-in functions?,Square root without built-in functions,"Input: 8, Output: 2; Input: 16, Output: 4",x is a non-negative integer.,https://leetcode.com/problems/Sqrt(x)/,Sqrt(x),Math,"['class Solution:\n    def mySqrt(self, x: int) -> int:\n        if 0 <= x < 2:\n            return x\n        \n        left, right = 1, x // 2\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right', '# Example usage:\ns = Solution()\n\nprint(s.mySqrt(4))  # Output: 2\nprint(s.mySqrt(8))  # Output: 2']"
How to express x^n for even and odd n?,Exponentiation rules for x,"Input: n = 4, Output: x^4 = (x^2)^2; Input: n = 5, Output: x^5 = x * (x^2)^2",n is a non-negative integer,"https://leetcode.com/problems/Pow(x,-n)/","Pow(x, n)",Math,"['class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n == 0:\n            return 1\n        if n == 1:\n            return x\n        \n        ans = 1\n        nn = abs(n)\n        while nn:\n            if nn % 2:\n                ans *= x\n                nn -= 1\n            else:\n                x *= x\n                nn //= 2\n        \n        if n < 0:\n            ans = 1 / ans\n        \n        return ans', '# Positive exponent\ns = Solution()\n\nassert abs(s.myPow(2.00000, 10) - 1024.00000) < 1e-5\nassert abs(s.myPow(2.10000, 3) - 9.26100) < 1e-5\n\n# Zero exponent\nassert s.myPow(2.00000, 0) == 1\n\nprint(""All test cases passed!"")']"
"Given an array of points on the X-Y plane, return the maximum number of points that lie on the same straight line.",Max points on a line,"Input: points = [[1,1],[2,2],[3,3]]; Output: 3","1 <= points.length <= 300; points[i].length == 2; -10^4 <= xi, yi <= 10^4; All points are unique.",https://leetcode.com/problems/Max-Points-on-a-Line/,Max Points on a Line,Math,"[""from collections import defaultdict\nfrom math import gcd\n\n\nclass Solution:\n    def maxPoints(self, points: list[list[int]]) -> int:\n        if len(points) <= 2:\n            return len(points)\n\n        result = 0\n        for i in range(len(points)):\n            slopes = defaultdict(int)\n            same_point_count = 1  # Count the current point itself\n            local_max = 0\n            for j in range(len(points)):\n                if i != j:\n                    if points[i] == points[j]:\n                        same_point_count += 1\n                    else:\n                        s = self.slope(points[i], points[j])\n                        slopes[s] += 1\n                        local_max = max(local_max, slopes[s])\n            \n            result = max(result, local_max + same_point_count)\n        \n        return result\n    \n    def slope(self, p1: list[int], p2: list[int]) -> tuple:\n        # Calculate the delta values\n        dx = p1[0] - p2[0]\n        dy = p1[1] - p2[1]\n        if dx == 0:  # vertical line\n            return ('inf', p1[0])  # Use a tuple ('inf', x-coordinate) to handle vertical lines uniquely by x-coordinate\n        g = gcd(dx, dy)\n        return (dy // g, dx // g)  # Normalize the slope by gcd to handle precision and reduce overflow"", '# TESTS\nfor points, expected in [\n    ([[1,1],[2,2],[3,3]], 3),\n    ([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]], 4),\n    ([[0,0],[1,1],[0,0]], 3),\n    ([[0,0],[1,1],[0,0],[1,1],[1,1],[1,1]], 6),\n    ([[0,0],[1,1],[0,0],[1,1],[1,1],[1,1],[1,1]], 7),\n    ([[0,0],[1,1],[0,0],[1,1],[1,1],[1,1],[1,1],[1,1]], 8),\n    ([[0,0],[1,1],[0,0],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1]], 9),\n    ([[0,0],[1,1],[0,0],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1]], 10),\n    ([[0,0],[1,1],[0,0],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1]], 11),\n]:\n    sol = Solution()\n    actual = sol.maxPoints(points)\n    print(""The maximum number of points on the same line in"", points, ""->"", actual)\n    assert actual == expected']"
You are climbing a staircase with `n` steps. Each time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?,Climbing stairs problem,"Input: n = 2, Output: 2; Input: n = 3, Output: 3",1 <= n <= 45,https://leetcode.com/problems/Climbing-Stairs/,Climbing Stairs,1D Dynamic Programming,"['class Solution:\n    # Time complexity: O(n)\n    # Space complexity: O(n)\n    def climbStairs(self, n: int) -> int:\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n\n        # initialize dp array\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n\n        # fill dp array\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n\n        return dp[n]\n    \n    # Time complexity: O(n)\n    # Space complexity: O(1)\n    def climb_stairs_optimized(self, n: int) -> int:\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n\n        # Only keep track of the last two values\n        a = 1\n        b = 2\n        for _ in range(3, n + 1):\n            c = a + b\n            a = b\n            b = c\n        \n        return b', '# Example usage:\ns = Solution()\n\nprint(s.climbStairs(2))  # Output: 2\nprint(s.climbStairs(3))  # Output: 3\n\nprint(s.climb_stairs_optimized(2))  # Output: 2\nprint(s.climb_stairs_optimized(3))  # Output: 3']"
How to implement the House Robber problem using dynamic programming?,House Robber problem solution,"Input: nums = [2, 7, 9, 3, 1]; Output: 12",0 <= nums.length <= 100; 0 <= nums[i] <= 400,https://leetcode.com/problems/House-Robber/,House Robber,1D Dynamic Programming,"['class Solution:\n    def rob(self, nums: list[int]) -> int:\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        if len(nums) == 2:\n            return max(nums)\n\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]', '# Testing\ns = Solution()\n\nnums = [2, 3, 2]\nprint(s.rob(nums))  # Expected 4']"
"Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.",Word segmentation problem,"Input: s = ""leetcode"", wordDict = [""leet"",""code""]
Output: true

Input: s = ""applepenapple"", wordDict = [""apple"",""pen""]
Output: true

Input: s = ""catsandog"", wordDict = [""cats"",""dog"",""sand"",""and"",""cat""]
Output: false",1 <= s.length <= 300; 1 <= wordDict.length <= 1000; 1 <= wordDict[i].length <= 20; s and wordDict[i] consist of only lowercase English letters; All strings in wordDict are unique.,https://leetcode.com/problems/Word-Break/,Word Break,1D Dynamic Programming,"['class Solution:\n    def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n        # convert wordDict to set for faster lookup\n        words = set(wordDict)\n\n        # initialize dp array where dp[i] is True if s[:i] can be segmented into words in words set\n        dp = [False] * (len(s) + 1)\n\n        # base case: empty string\n        dp[0] = True\n\n        # iterate through s\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in words:\n                    dp[i] = True\n                    # break inner loop if dp[i] is True\n                    break\n\n        # The result for the whole string s is stored in dp[len(s)]\n        return dp[-1]', '# Example usage:\ns = Solution()\n\ns1 = ""leetcode""\nwordDict1 = [""leet"", ""code""]\nprint(s.wordBreak(s1, wordDict1))  # Output: true\n\ns2 = ""applepenapple""\nwordDict2 = [""apple"", ""pen""]\nprint(s.wordBreak(s2, wordDict2))  # Output: true\n\ns3 = ""catsandog""\nwordDict3 = [""cats"", ""dog"", ""sand"", ""and"", ""cat""]\nprint(s.wordBreak(s3, wordDict3))  # Output: false']"
"Given an array of coin denominations and a total amount, return the fewest number of coins needed to make that amount, or -1 if it's not possible.",Fewest coins for amount,"Input: coins = [1,2,5], amount = 11; Output: 3. Input: coins = [2], amount = 3; Output: -1. Input: coins = [1], amount = 0; Output: 0.","1 <= coins.length <= 12, 1 <= coins[i] <= 2^31 - 1, 0 <= amount <= 10^4",https://leetcode.com/problems/Coin-Change/,Coin Change,1D Dynamic Programming,"['class Solution:\n    def coinChange(self, coins: list[int], amount: int) -> int:\n        # large number to represent infinity\n        max_value = amount + 1\n\n        # create a list of size amount + 1\n        # (dp[i] represents the minimum number of coins needed to make up the amount i)\n        dp = [max_value] * (amount + 1)\n\n        # base case\n        dp[0] = 0\n\n        # fill the dp list using the coins\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n        # if dp[amount] is still the initial max_value, then it means it is impossible to make up the amount\n        return dp[amount] if dp[amount] != max_value else -1', '# Example usage:\ns = Solution()\n\nprint(s.coinChange([1, 2, 5], 11))  # Output: 3\nprint(s.coinChange([2], 3))         # Output: -1\nprint(s.coinChange([1], 0))         # Output: 0']"
"Given an integer array `nums`, return the length of the longest strictly increasing subsequence.",Longest Increasing Subsequence Length,"Input: nums = [10,9,2,5,3,7,101,18] Output: 4; Input: nums = [0,1,0,3,2,3] Output: 4; Input: nums = [7,7,7,7,7,7,7] Output: 1",1 <= nums.length <= 2500; -10^4 <= nums[i] <= 10^4,https://leetcode.com/problems/Longest-Increasing-Subsequence/,Longest Increasing Subsequence,1D Dynamic Programming,"['class Solution:\n    def lengthOfLIS(self, nums: list[int]) -> int:\n        n = len(nums)\n\n        # if the list is empty, return 0\n        if not nums:\n            return 0\n\n        # create a list to store the length of the longest increasing subsequence\n        dp = [1] * n\n\n        # fill the dp list\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n\n        # return the maximum value in the dp list\n        return max(dp)', '# Example calls\ns = Solution()\n\nprint(s.lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]))  # Output: 4\nprint(s.lengthOfLIS([0, 1, 0, 3, 2, 3]))            # Output: 4\nprint(s.lengthOfLIS([7, 7, 7, 7, 7, 7, 7]))         # Output: 1']"
"Given a triangle of numbers, calculate the minimum path sum from the top to the bottom by moving to adjacent numbers in the row below.",Minimum path sum in triangle,"Input: [[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]]; Output: 11",The triangle will have at least one row and each row will have one more element than the previous row.,https://leetcode.com/problems/Triangle/,Triangle,Multidimensional Dynamic Programming,"['class Solution:\n    # Solve with dynamic programming\n    # Time complexity: O(n^2) where n is the number of rows in the triangle\n    # Space complexity: O(1) since we are modifying the input list in place\n    def minimumTotal(self, triangle: list[list[int]]) -> int:\n        # start from the second to last row and work our way up\n        for i in range(len(triangle) - 2, -1, -1):\n            for j in range(len(triangle[i])):\n                # get the minimum of the two adjacent numbers in the row below\n                triangle[i][j] += min(triangle[i + 1][j],\n                                      triangle[i + 1][j + 1])\n\n        return triangle[0][0]', '# Example usage\ns = Solution()\n\ntriangle1 = [[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]]\ntriangle2 = [[-10]]\nprint(s.minimumTotal(triangle1))  # Output: 11\nprint(s.minimumTotal(triangle2))  # Output: -10']"
"Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right that minimizes the sum of all numbers along its path, moving only down or right.",Minimum path sum in grid,"Input: grid = [[1,3,1],[1,5,1],[4,2,1]]; Output: 7. Input: grid = [[1,2,3],[4,5,6]]; Output: 12.","1 <= m, n <= 200; 0 <= grid[i][j] <= 200.",https://leetcode.com/problems/Minimum-Path-Sum/,Minimum Path Sum,Multidimensional Dynamic Programming,"['class Solution:\n    # O(m * n) time complexity\n    # O(m * n) space complexity\n    def minPathSum(self, grid: list[list[int]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n\n        # top left corner\n        dp[0][0] = grid[0][0]\n\n        # first column\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n\n        # first row\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] + grid[0][j]\n\n        # fill the rest of the dp table\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\n        return dp[m - 1][n - 1]\n    \n    # O(m * n) time complexity\n    # O(1) space complexity\n    def minPathSumInPlace(self, grid: list[list[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n\n        # Update the first row (accumulate values)\n        for j in range(1, n):\n            grid[0][j] += grid[0][j - 1]\n\n        # Update the first column (accumulate values)\n        for i in range(1, m):\n            grid[i][0] += grid[i - 1][0]\n\n        # Update the rest of the grid\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n\n        return grid[m - 1][n - 1]\n', '# Test Cases\nsol = Solution()\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nassert sol.minPathSum(grid) == 7\nassert sol.minPathSumInPlace(grid) == 7\n\ngrid = [[1, 2, 3], [4, 5, 6]]\nassert sol.minPathSum(grid) == 12\nassert sol.minPathSumInPlace(grid) == 12\n\ngrid = [[1, 2], [1, 1]]\nassert sol.minPathSum(grid) == 3\nassert sol.minPathSumInPlace(grid) == 3\n\ngrid = [[1, 2, 5], [3, 2, 1]]\nassert sol.minPathSum(grid) == 6\nassert sol.minPathSumInPlace(grid) == 6']"
"Given an m x n grid with obstacles, calculate the number of unique paths from the top-left to the bottom-right corner, moving only down or right.",Count unique paths with obstacles,"Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]; Output: 2","1 <= m, n <= 100; obstacleGrid[i][j] is 0 or 1.",https://leetcode.com/problems/Unique-Path-II/,Unique Path II,Multidimensional Dynamic Programming,"['class Solution:\n    # O(m * n) time complexity, O(m * n) space complexity\n    def uniquePathsWithObstacles(self, obstacleGrid: list[list[int]]) -> int:\n        if not obstacleGrid or obstacleGrid[0][0] == 1:\n            return 0\n\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n\n        # first row\n        for i in range(1, m):\n            # if a cell is not an obstacle and the previous cell in dp is reachable, \n            # then the current cell in dp is also reachable\n            if obstacleGrid[i][0] == 0 and dp[i - 1][0] == 1:\n                dp[i][0] = 1\n\n        # first column\n        for j in range(1, n):\n            if obstacleGrid[0][j] == 0 and dp[0][j - 1] == 1:\n                dp[0][j] = 1\n\n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n        return dp[-1][-1]', '# test cases\ns = Solution()\nobstacleGrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\nprint(s.uniquePathsWithObstacles(obstacleGrid))  # 2\n\nobstacleGrid = [[0, 1], [0, 0]]\nprint(s.uniquePathsWithObstacles(obstacleGrid))  # 1']"
"Given a string `s`, return the longest palindromic substring in `s`.",Longest palindromic substring,Input: s = 'babad' Output: 'bab' Input: s = 'cbbd' Output: 'bb',1 <= s.length <= 1000; s consists of only digits and English letters.,https://leetcode.com/problems/Longest-Palindromic-Substring/,Longest Palindromic Substring,Multidimensional Dynamic Programming,"[""class Solution:\n    # O(n^2) time complexity: two nested loops\n    # O(1) space complexity: only a few variables used\n    def longestPalindrome(self, s: str) -> str:\n        # Helper function to expand around a center.\n        def expand_around_center(left: int, right: int) -> str:\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            # Return the palindrome found.\n            return s[left + 1:right]\n\n        # If the string is less than 2 characters, it's a palindrome by itself.\n        if len(s) < 2:\n            return s\n\n        # Keep track of the longest palindrome found so far.\n        longest = ''\n        for i in range(len(s)):\n            # Check for both odd and even length palindromes.\n            odd_palindrome = expand_around_center(i, i)\n            even_palindrome = expand_around_center(i, i + 1)\n            longest = max(longest, odd_palindrome, even_palindrome, key=len)\n\n        return longest"", 's = Solution()\n\nprint(s.longestPalindrome(""babad""))  # ""bab"" or ""aba""\nprint(s.longestPalindrome(""cbbd""))  # ""bb""\nprint(s.longestPalindrome(""a""))  # ""a""\nprint(s.longestPalindrome(""ac""))  # ""a""\nprint(s.longestPalindrome(""bb""))  # ""bb""']"
"Given strings s1, s2, and s3, determine if s3 is formed by interleaving s1 and s2.",Check interleaving of strings,"Input: s1 = ""aabcc"", s2 = ""dbbca"", s3 = ""aadbbcbcac""; Output: true","0 <= s1.length, s2.length <= 100; 0 <= s3.length <= 200; s1, s2, and s3 consist of lowercase English letters.",https://leetcode.com/problems/Interleaving-String/,Interleaving String,Multidimensional Dynamic Programming,"['class Solution:\n    # time complexity: O(len(s1) * len(s2))\n    # space complexity: O(min(len(s1), len(s2)))\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        # inital check for the length of s3\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        # s1 is the longer string\n        if len(s1) < len(s2):\n            s1, s2 = s2, s1\n\n        # dp[j] means whether s1[:i] and s2[:j] can interleave to s3[:i+j]\n        dp = [True] + [False] * len(s2)\n\n        # fill the dp array for the first row\n        for j in range(1, len(s2) + 1):\n            # check if the first j characters of s2 match the first j characters of s3\n            dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\n\n        # main dp loop\n        for i in range(1, len(s1) + 1):\n            # check if the first i characters of s1 match the first i characters of s3\n            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\n            for j in range(1, len(s2) + 1):\n                # check if the first i + j characters of s1 and s2 match the first i + j characters of s3\n                dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]\n                         ) or (dp[j - 1] and s2[j - 1] == s3[i + j - 1])\n\n        return dp[-1]', '# Test cases\ns = Solution()\n\nprint(s.isInterleave(""aabcc"", ""dbbca"", ""aadbbcbcac""))  # Output: true\nprint(s.isInterleave(""aabcc"", ""dbbca"", ""aadbbbaccc""))  # Output: false\nprint(s.isInterleave("""", """", """"))  # Output: true']"
"Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2` using insert, delete, or replace operations.",Calculate edit distance,"Input: word1 = ""horse"", word2 = ""ros""; Output: 3","0 <= word1.length, word2.length <= 500; word1 and word2 consist of lowercase English letters.",https://leetcode.com/problems/Edit-Distance/,Edit Distance,Multidimensional Dynamic Programming,"['class Solution:\n    # complexity: O(m * n) time, O(m * n) space\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n\n        # dp[i][j] is the minimum number of ops to convert word1[:i] to word2[:j]\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        # base case\n        for i in range(1, m + 1):\n            dp[i][0] = i  # cost to delete i characters from word1\n        for j in range(1, n + 1):\n            dp[0][j] = j  # cost to delete j characters from word2\n\n        # fill the dp table\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                # if the characters are the same, no op needed\n                if word1[i - 1] == word2[j - 1]:\n                    # no op needed, inherit the cost\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(\n                        dp[i - 1][j] + 1,  # delete\n                        dp[i][j - 1] + 1,  # insert\n                        dp[i - 1][j - 1] + 1  # replace\n                    )\n\n        return dp[m][n]', '# Example usage\ns = Solution()\n\nprint(s.minDistance(""horse"", ""ros""))  # Output: 3\nprint(s.minDistance(""intention"", ""execution""))  # Output: 5']"
"Given an array of stock prices, find the maximum profit you can achieve with at most two transactions, ensuring you sell before buying again.",Max profit with two transactions,"Input: prices = [3,3,5,0,0,3,1,4], Output: 6; Input: prices = [1,2,3,4,5], Output: 4; Input: prices = [7,6,4,3,1], Output: 0.",1 <= prices.length <= 10^5; 0 <= prices[i] <= 10^5,https://leetcode.com/problems/Best-Time-to-Buy-and-Sell-Stock-III/,Best Time to Buy and Sell Stock III,Multidimensional Dynamic Programming,"['class Solution:\n    # O(n) time | O(n) space\n    def maxProfit(self, prices: list[int]) -> int:\n        if not prices:\n            return 0\n\n        n = len(prices)\n\n        # profit1 holds the max profit achievable with one transaction up to day i\n        profit1 = [0] * n\n        # profit2 holds the max profit achievable with two transactions up to day i\n        profit2 = [0] * n\n\n        # for profit1, we need to keep track of the minimum price so far\n        min_price = prices[0]\n        for i in range(1, n):\n            min_price = min(min_price, prices[i])\n            profit1[i] = max(profit1[i - 1], prices[i] - min_price)\n\n        # for profit2, we need to keep track of the minimum price after the first sale\n        min_price_after_first_sale = prices[0] - profit1[0]\n        for i in range(1, n):\n            min_price_after_first_sale = min(\n                min_price_after_first_sale, prices[i] - profit1[i])\n            profit2[i] = max(profit2[i - 1], prices[i] -\n                             min_price_after_first_sale)\n\n        return profit2[-1]', '# Test cases\ns = Solution()\n\nprices1 = [3, 3, 5, 0, 0, 3, 1, 4]\nprices2 = [1, 2, 3, 4, 5]\nprices3 = [7, 6, 4, 3, 1]\n\nprint(s.maxProfit(prices1))  # Output: 6\nprint(s.maxProfit(prices2))  # Output: 4\nprint(s.maxProfit(prices3))  # Output: 0']"
"Given an integer array `prices` and an integer `k`, find the maximum profit achievable with at most `k` transactions, where you cannot engage in multiple transactions simultaneously.",Max profit with k transactions,"Input: k = 2, prices = [2,4,1] Output: 2; Input: k = 2, prices = [3,2,6,5,0,3] Output: 7",1 <= k <= 100; 1 <= prices.length <= 1000; 0 <= prices[i] <= 1000,https://leetcode.com/problems/Best-Time-to-Buy-and-Sell-Stock-IV/,Best Time to Buy and Sell Stock IV,Multidimensional Dynamic Programming,"['class Solution:\n    # O(min(kn, n)) time | O(n) space\n    def maxProfit(self, k: int, prices: list[int]) -> int:\n        if not prices:\n            return 0\n\n        n = len(prices)\n\n        if k >= n // 2:\n            # k is large enough to cover all transactions\n            return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1))\n\n        # dp[i] is the maximum profit with at most i transactions\n        dp = [0] * n\n\n        for i in range(1, k + 1):\n            max_diff = -prices[0]\n            new_dp = [0] * n\n            for j in range(1, n):\n                new_dp[j] = max(new_dp[j - 1], prices[j] + max_diff)\n                max_diff = max(max_diff, dp[j] - prices[j])\n\n            dp = new_dp\n\n        return dp[-1]', '# Test cases\ns = Solution()\n\nprint(s.maxProfit(2, [2, 4, 1]))  # Output: 2\nprint(s.maxProfit(2, [3, 2, 6, 5, 0, 3]))  # Output: 7']"
"Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.",Find largest square area,"Input: matrix = [[""1"",""0"",""1"",""0"",""0""],[""1"",""0"",""1"",""1"",""1""],[""1"",""1"",""1"",""1"",""1""],[""1"",""0"",""0"",""1"",""0""]], Output: 4","1 <= m, n <= 300; matrix[i][j] is '0' or '1'.",https://leetcode.com/problems/Maximal-Square/,Maximal Square,Multidimensional Dynamic Programming,"[""class Solution:\n    # O(m*n) time complexity: iterate through all cells\n    # O(m*n) space complexity: store the side length of the largest square for each cell\n    def maximalSquare(self, matrix: list[list[str]]) -> int:\n        if not matrix:\n            return 0\n\n        m, n = len(matrix), len(matrix[0])\n\n        # dp[i][j] represents the side length of the maximum square that\n        # can be formed with the cell matrix[i][j] as the bottom-right cell\n        dp = [[0] * n for _ in range(m)]\n        max_side = 0\n\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    # if any cell in the first row or first column is '1',\n                    # the side of the square is at least 1 because the square is formed by the cell itself\n                    if i == 0 or j == 0:\n                        dp[i][j] = 1\n                    else:\n                        dp[i][j] = min(dp[i - 1][j],\n                                       dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                    max_side = max(max_side, dp[i][j])\n\n        return max_side * max_side"", 's = Solution()\n\n# Example 1\nmatrix = [[""1"", ""0"", ""1"", ""0"", ""0""], [""1"", ""0"", ""1"", ""1"", ""1""],\n          [""1"", ""1"", ""1"", ""1"", ""1""], [""1"", ""0"", ""0"", ""1"", ""0""]]\nprint(s.maximalSquare(matrix))  # Output: 4\n\n# Example 2\nmatrix = [[""0"", ""1""], [""1"", ""0""]]\nprint(s.maximalSquare(matrix))  # Output: 1\n\n# Example 3\nmatrix = [[""0""]]\nprint(s.maximalSquare(matrix))  # Output: 0']"
"Determine if a 9 x 9 Sudoku board is valid based on specific rules for rows, columns, and 3 x 3 sub-boxes.",Validate a Sudoku board,"Input: board = [[""5"",""3"",""."",""."",""7"",""."",""."",""."","".""],[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""],[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""],[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""],[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""],[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""],[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""],[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""],[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]] Output: true",1. board.length == 9 2. board[i].length == 9 3. board[i][j] is a digit 1-9 or '.'.,https://leetcode.com/problems/Valid-Sudoku/,Valid Sudoku,Matrix,"['class Solution:\n    # solve in O(n^2) time and O(1) extra space\n    def isValidSudoku(self, board: list[list[str]]) -> bool:\n        def is_valid_block(block: list[str]) -> bool:\n            block = [x for x in block if x != "".""]\n            return len(set(block)) == len(block)\n\n        # check each row\n        for row in board:\n            if not is_valid_block(row):\n                return False\n\n        # check each column\n        for col in zip(*board):\n            if not is_valid_block(col):\n                return False\n\n        # check each 3x3 sub-box\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                block = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if not is_valid_block(block):\n                    return False\n\n        return True', 'isValidSudoku = Solution().isValidSudoku\n\n# Example 1\nboard1 = [\n    [""5"", ""3"", ""."", ""."", ""7"", ""."", ""."", ""."", "".""],\n    [""6"", ""."", ""."", ""1"", ""9"", ""5"", ""."", ""."", "".""],\n    [""."", ""9"", ""8"", ""."", ""."", ""."", ""."", ""6"", "".""],\n    [""8"", ""."", ""."", ""."", ""6"", ""."", ""."", ""."", ""3""],\n    [""4"", ""."", ""."", ""8"", ""."", ""3"", ""."", ""."", ""1""],\n    [""7"", ""."", ""."", ""."", ""2"", ""."", ""."", ""."", ""6""],\n    [""."", ""6"", ""."", ""."", ""."", ""."", ""2"", ""8"", "".""],\n    [""."", ""."", ""."", ""4"", ""1"", ""9"", ""."", ""."", ""5""],\n    [""."", ""."", ""."", ""."", ""8"", ""."", ""."", ""7"", ""9""],\n]\n\n# Example 2\nboard2 = [\n    [""8"", ""3"", ""."", ""."", ""7"", ""."", ""."", ""."", "".""],\n    [""6"", ""."", ""."", ""1"", ""9"", ""5"", ""."", ""."", "".""],\n    [""."", ""9"", ""8"", ""."", ""."", ""."", ""."", ""6"", "".""],\n    [""8"", ""."", ""."", ""."", ""6"", ""."", ""."", ""."", ""3""],\n    [""4"", ""."", ""."", ""8"", ""."", ""3"", ""."", ""."", ""1""],\n    [""7"", ""."", ""."", ""."", ""2"", ""."", ""."", ""."", ""6""],\n    [""."", ""6"", ""."", ""."", ""."", ""."", ""2"", ""8"", "".""],\n    [""."", ""."", ""."", ""4"", ""1"", ""9"", ""."", ""."", ""5""],\n    [""."", ""."", ""."", ""."", ""8"", ""."", ""."", ""7"", ""9""],\n]\n\nisValidSudoku(board1), isValidSudoku(board2)']"
"Given an m x n matrix, return all elements of the matrix in spiral order.",Return matrix in spiral order,"Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]; Output: [1,2,3,6,9,8,7,4,5]","1 <= m, n <= 10; -100 <= matrix[i][j] <= 100",https://leetcode.com/problems/Spiral-Matrix/,Spiral Matrix,Matrix,"['class Solution:\n    # O(N) time complexity: each element is visited once; N = m * n\n    # O(1) space complexity: no additional space required\n    def spiralOrder(self, matrix: list[list[int]]) -> list[int]:\n        if not matrix or not matrix[0]:\n            return []\n\n        m, n = len(matrix), len(matrix[0])\n        res: list[int] = []\n        left, right, top, bottom = 0, n - 1, 0, m - 1\n\n        while left <= right and top <= bottom:\n            # left to right\n            for j in range(left, right + 1):\n                res.append(matrix[top][j])\n            top += 1  # reaches the rightmost column, time to move down\n\n            # top to bottom\n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1  # reaches the bottom row, time to move left\n\n            # right to left\n            if top <= bottom:\n                for j in range(right, left - 1, -1):\n                    res.append(matrix[bottom][j])\n                bottom -= 1  # reaches the leftmost column, time to move up\n\n            # bottom to top\n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n                left += 1  # reaches the top row, time to move right\n\n        return res', '# Test the function with the provided examples\n\nspiralOrder = Solution().spiralOrder\n\nexample1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nexample2 = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n\noutput1 = spiralOrder(example1)\noutput2 = spiralOrder(example2)\noutput1, output2']"
"You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise) in-place without allocating another 2D matrix.",Rotate image 90 degrees,"Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]; Output: [[7,4,1],[8,5,2],[9,6,3]]; Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]; Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",n == matrix.length == matrix[i].length; 1 <= n <= 20; -1000 <= matrix[i][j] <= 1000,https://leetcode.com/problems/Rotate-Image/,Rotate Image,Matrix,"['class Solution:\n    # O(n^2) time complexity: transpose is O(n^2), reverse is O(n)\n    # O(1) space complexity: in-place\n    def rotate(self, matrix: list[list[int]]) -> None:\n        n = len(matrix)\n\n        # transpose the matrix\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n        # reverse each row\n        for i in range(n):\n            matrix[i].reverse()\n\n        return matrix', '# Test the function with the provided examples\n\nrotate = Solution().rotate\n\nmatrix1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nmatrix2 = [[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]]\n\nrotate(matrix1), rotate(matrix2)']"
"Given an m x n integer matrix, if an element is 0, set its entire row and column to 0's in place.",Set matrix zeroes in place,"Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]; Output: [[1,0,1],[0,0,0],[1,0,1]]; Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]; Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]","m == matrix.length; n == matrix[0].length; 1 <= m, n <= 200; -2^31 <= matrix[i][j] <= 2^31 - 1",https://leetcode.com/problems/Set-Matrix-Zeroes/,Set Matrix Zeroes,Matrix,"['class Solution:\n    def setZeroes(self, matrix: list[list[int]]) -> list[list[int]]:\n        m, n = len(matrix), len(matrix[0])\n\n        # check if first row and col need to be set to 0\n        first_row_zero: bool = any(matrix[0][j] == 0 for j in range(n))\n        first_col_zero: bool = any(matrix[i][0] == 0 for i in range(m))\n\n        # use first row and col to mark if a row or col needs to be set to 0\n        # If a cell matrix[i][j] is zero, set the corresponding values in the first row and first column to zero.\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = matrix[0][j] = 0\n\n        # set the corresponding rows and columns to zero\n        # After processing all the elements except for the first row and first column,\n        # iterate through the first row and first column to zero out the rows and columns\n        # based on the information stored in them.\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n\n        # set first row and col to zero if needed\n        if first_row_zero:\n            for j in range(n):\n                matrix[0][j] = 0\n\n        if first_col_zero:\n            for i in range(m):\n                matrix[i][0] = 0', '# Tests\n\nsetZeroes = Solution().setZeroes\n\nmatrix1 = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\nsetZeroes(matrix1)\nassert matrix1 == [[1, 0, 1], [0, 0, 0], [1, 0, 1]]\n\nmatrix2 = [[0, 1, 2, 0], [3, 4, 5, 2], [1, 3, 1, 5]]\nsetZeroes(matrix2)\nassert matrix2 == [[0, 0, 0, 0], [0, 4, 5, 0], [0, 3, 1, 0]]']"
"Given a board representing the current state of the Game of Life, return the next state after applying the rules of the game.",Next state of Game of Life,"Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]; Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]","1 <= m, n <= 25; board[i][j] is 0 or 1.",https://leetcode.com/problems/Game-of-Life/,Game of Life,Matrix,"['class Solution:\n    # O(mn) time complexity, O(mn) space complexity\n    def gameOfLife(self, board: list[list[int]]) -> None:\n        """"""\n        Do not return anything, modify board in-place instead.\n        """"""\n        # 8 directions of neighbors\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0),\n                      (1, 1), (-1, -1), (-1, 1), (1, -1)]\n\n        # get the number of live neighbors\n        def count_live_neighbors(row, col):\n            live_neighbors = 0\n            for dr, dc in directions:\n                r = row + dr\n                c = col + dc\n                if 0 <= r < len(board) and 0 <= c < len(board[0]):\n                    live_neighbors += board[r][c] & 1\n            return live_neighbors\n\n        # copy the board ti store the next state\n        new_board = [[0] * len(board[0]) for _ in range(len(board))]\n\n        # apply rules to each cell\n        for row in range(len(board)):\n            for col in range(len(board[0])):\n                live_neighbors = count_live_neighbors(row, col)\n                # rules 1-3 for live cells\n                if board[row][col] == 1 and 2 <= live_neighbors <= 3:\n                    # live cell with 2 or 3 neighbors lives on\n                    new_board[row][col] = 1\n                # rule 4 for live cells\n                elif board[row][col] == 0 and live_neighbors == 3:\n                    # dead cell with 3 neighbors becomes alive\n                    new_board[row][col] = 1\n\n        # update the original board\n        for row in range(len(board)):\n            for col in range(len(board[0])):\n                board[row][col] = new_board[row][col]', '# Example usage\n\ngameOfLife = Solution().gameOfLife\n\nboard = [[0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0]]\ngameOfLife(board)\nprint(board)\n\nboard2 = [[1, 1], [1, 0]]\ngameOfLife(board2)\nprint(board2)']"
